<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Timeline Prototype - Phuzzy's Think Tank</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            color: white;
            text-align: center;
            font-size: 2.5rem;
            margin-bottom: 30px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .demo-card {
            background: white;
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.2);
        }
        
        .scenario-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
        }
        
        .scenario-title {
            font-size: 1.8rem;
            font-weight: 700;
            color: #2d3748;
        }
        
        .correct-badge {
            padding: 8px 20px;
            border-radius: 25px;
            font-weight: 600;
            color: white;
            font-size: 0.9rem;
        }
        
        .badge-emotion { background: #ec4899; }
        .badge-balanced { background: #10b981; }
        
        .scenario-text {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 15px;
            margin-bottom: 30px;
            line-height: 1.8;
            font-size: 1.1rem;
            border-left: 5px solid #667eea;
            min-height: 120px; /* Prevent height changes */
            position: relative;
            overflow: hidden;
        }
        
        .viz-container {
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }
        
        .radar-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            text-align: center;
        }
        
        .timeline-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            position: relative;
        }
        
        .bear-paw-icon {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 51px;
            height: 51px;
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 300;
            color: #fefefe;
            transform: rotate(-15deg);
        }
        
        .bear-paw-icon:hover {
            transform: rotate(-15deg) scale(1.1);
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.5);
        }
        
        .bear-paw-icon:active {
            transform: rotate(-15deg) scale(0.95);
        }
        
        .bear-paw-icon.cooldown {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .bear-flyout {
            position: absolute;
            top: 15px;
            right: 15px;
            background: linear-gradient(135deg, #fef7cd 0%, #fef3c7 100%);
            border: 3px solid #f59e0b;
            border-radius: 15px;
            padding: 20px 15px 15px 15px;
            min-width: 180px;
            max-width: 220px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
            z-index: 250;
            display: none;
            animation: slideOut 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            transform-origin: top right;
        }
        
        @keyframes slideOut {
            from {
                transform: translateY(-20px) scale(0.8);
                opacity: 0;
            }
            to {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
        }
        
        @keyframes slideIn {
            from {
                transform: translateY(0) scale(1);
                opacity: 1;
            }
            to {
                transform: translateY(-20px) scale(0.8);
                opacity: 0;
            }
        }
        
        .bear-timer-bar {
            background: #e5e7eb;
            height: 12px;
            border-radius: 6px;
            margin: 0 0 8px 0;
            overflow: hidden;
            position: relative;
        }
        
        .bear-timer-fill {
            background: linear-gradient(90deg, #10b981 0%, #fbbf24 50%, #ef4444 100%);
            height: 100%;
            border-radius: 4px;
            transition: width 1s linear;
            width: 100%;
        }
        
        .bear-push-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(59, 130, 246, 0.4) !important;
        }
        
        .bear-push-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3) !important;
        }
        
        .doom-countdown {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10000;
            font-size: 8rem;
            font-weight: 900;
            color: #1f2937;
            text-shadow: 
                0 0 10px #ef4444, 0 0 20px #ef4444, 0 0 30px #ef4444,
                0 0 40px #ef4444, 0 0 50px #ef4444, 0 0 60px #ef4444,
                2px 2px 0px #ef4444, -2px -2px 0px #ef4444,
                2px -2px 0px #ef4444, -2px 2px 0px #ef4444;
            animation: doomPulse 1s infinite;
            pointer-events: none;
            font-family: 'Impact', 'Arial Black', sans-serif;
            letter-spacing: 0.1em;
            -webkit-text-stroke: 1px #ef4444;
        }
        
        @keyframes doomPulse {
            0%, 100% { 
                transform: translate(-50%, -50%) scale(1); 
                opacity: 0.9;
            }
            50% { 
                transform: translate(-50%, -50%) scale(1.2); 
                opacity: 1;
                text-shadow: 
                    0 0 15px #ef4444, 0 0 30px #ef4444, 0 0 45px #ef4444,
                    0 0 60px #ef4444, 0 0 75px #ef4444, 0 0 90px #ef4444,
                    3px 3px 0px #ef4444, -3px -3px 0px #ef4444,
                    3px -3px 0px #ef4444, -3px 3px 0px #ef4444;
            }
        }
        
        .timeline-section.urgent {
            animation: urgentFlash 0.5s infinite;
        }
        
        @keyframes urgentFlash {
            0%, 100% { border-color: transparent; }
            50% { border-color: #ef4444; border-width: 3px; }
        }
        
        .spark-effect {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #fbbf24;
            border-radius: 50%;
            pointer-events: none;
            animation: sparkFly 0.8s ease-out forwards;
        }
        
        @keyframes sparkFly {
            0% {
                transform: scale(1);
                opacity: 1;
            }
            100% {
                transform: scale(0) translate(20px, -20px);
                opacity: 0;
            }
        }
        
        .section-title {
            font-size: 1.2rem;
            font-weight: 600;
            color: #4b5563;
            margin-bottom: 15px;
            text-align: center;
        }
        
        canvas {
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            display: block;
            margin: 0 auto;
        }
        
        .controls {
            background: rgba(255,255,255,0.9);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            margin-top: 20px;
        }
        
        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            margin: 0 10px;
            transition: all 0.3s ease;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        .legend {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 20px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .legend-color {
            width: 24px;
            height: 4px;
            border-radius: 2px;
        }
        
        .logic-color { background: #3b82f6; }
        .emotion-color { background: #ec4899; }
        .balanced-color { background: #10b981; }
        .agenda-color { background: #f59e0b; }
        
        .info-box {
            background: #e0f2fe;
            border: 1px solid #0288d1;
            border-radius: 10px;
            padding: 15px;
            margin: 20px 0;
        }
        
        .info-title {
            font-weight: 600;
            color: #0277bd;
            margin-bottom: 8px;
        }
        
        .explanatory-section {
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .explanation-title {
            font-size: 1.3rem;
            font-weight: 700;
            color: #2d3748;
            margin-bottom: 15px;
            text-align: center;
        }
        
        .explanation-content {
            line-height: 1.7;
            color: #4a5568;
        }
        
        .explanation-content p {
            margin-bottom: 15px;
        }
        
        .explanation-content strong {
            color: #2d3748;
        }
        
        .highlight-emotion {
            background-color: #fce7f3;
            color: #ec4899;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
        }
        
        .highlight-logic {
            background-color: #dbeafe;
            color: #3b82f6;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
        }
        
        .highlight-balanced {
            background-color: #d1fae5;
            color: #10b981;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
        }
        
        .highlight-agenda {
            background-color: #fef3c7;
            color: #f59e0b;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
        }
        
        .dimension-toggles {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            justify-content: center;
            flex-wrap: wrap;
            min-height: 40px; /* Prevent layout shift */
        }
        
        .toggle-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 20px;
            border: 2px solid #e5e7eb;
            background: white;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.15s ease, border-color 0.15s ease;
            will-change: background, border-color; /* Optimize for transitions */
        }
        
        .toggle-btn:hover {
            background: #f9fafb;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .toggle-btn.active {
            border-color: currentColor;
            background: #f9fafb;
        }
        
        .toggle-btn.logic-toggle.active { border-color: #3b82f6; color: #3b82f6; }
        .toggle-btn.emotion-toggle.active { border-color: #ec4899; color: #ec4899; }
        .toggle-btn.balanced-toggle.active { border-color: #10b981; color: #10b981; }
        .toggle-btn.agenda-toggle.active { border-color: #f59e0b; color: #f59e0b; }
        
        .toggle-btn:not(.active) {
            opacity: 0.6;
            color: #4b5563; /* Ensure text is visible */
        }
        
        .toggle-btn.highlight-mode {
            background: currentColor !important;
            position: relative;
        }
        
        .toggle-btn.highlight-mode {
            color: white !important;
        }
        
        .toggle-btn.highlight-mode .bar-label,
        .toggle-btn.highlight-mode span {
            color: white !important;
            font-weight: 700;
            text-shadow: 0 0 2px rgba(0,0,0,0.3);
        }
        
        .toggle-btn.highlight-mode .toggle-color {
            background: white !important;
            box-shadow: 0 0 4px rgba(0,0,0,0.2);
        }
        
        .toggle-btn.highlight-mode::after {
            content: '‚ú®';
            margin-left: 4px;
            font-size: 1.1em;
            filter: brightness(2) drop-shadow(0 0 3px rgba(255,255,255,0.8));
        }
        
        .toggle-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
        }
        
        .logic-color { background: #3b82f6; }
        .emotion-color { background: #ec4899; }
        .balanced-color { background: #10b981; }
        .agenda-color { background: #f59e0b; }
        
        /* Hover effect for desktop */
        @media (hover: hover) {
            .toggle-btn.active:hover {
                box-shadow: 0 0 0 3px currentColor;
                background: #fef3c7;
            }
        }
        
        .radar-legend {
            margin-top: 15px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        
        .radar-bar {
            height: 28px;
            background: #f3f4f6;
            border-radius: 14px;
            position: relative;
            display: flex;
            align-items: center;
            overflow: visible;
            font-size: 0.8rem;
            font-weight: 600;
        }
        
        .radar-bar-fill {
            height: 100%;
            border-radius: 14px;
            background: currentColor;
            position: absolute;
            left: 0;
            top: 0;
            transition: all 0.5s ease;
            min-width: 35px;
        }
        
        .radar-bar.logic-bar .radar-bar-fill { background: #3b82f6; }
        .radar-bar.emotion-bar .radar-bar-fill { background: #ec4899; }
        .radar-bar.balanced-bar .radar-bar-fill { background: #10b981; }
        .radar-bar.agenda-bar .radar-bar-fill { background: #f59e0b; }
        
        .bar-content {
            position: relative;
            z-index: 1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            padding: 0 12px;
        }
        
        .bar-label {
            white-space: nowrap;
            color: #374151;
            margin-right: 10px;
        }
        
        .bar-value {
            color: white;
            background: rgba(0,0,0,0.2);
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.7rem;
        }
        
        @keyframes sparkle-move {
            from { offset-distance: 0%; }
            to { offset-distance: 100%; }
        }
        
        .sparkle {
            position: absolute;
            width: 10px;
            height: 10px;
            pointer-events: none;
            z-index: 100;
        }
        
        .sparkle::before {
            content: '‚ú®';
            position: absolute;
            left: -5px;
            top: -5px;
            font-size: 16px;
            animation: sparkle-rotate 1s linear infinite;
        }
        
        @keyframes sparkle-rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }
        
        .mini-game-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.6);
            z-index: 2000;
            display: none;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(3px);
        }
        
        .mini-game-popup {
            background: linear-gradient(135deg, #fef7cd 0%, #fef3c7 100%);
            border: 4px solid #f59e0b;
            border-radius: 25px;
            padding: 30px;
            text-align: center;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            margin: 20px;
            position: relative;
            animation: popupAppear 0.5s ease-out;
        }
        
        @keyframes popupAppear {
            from {
                transform: scale(0.8) translateY(20px);
                opacity: 0;
            }
            to {
                transform: scale(1) translateY(0);
                opacity: 1;
            }
        }
        
        .popup-close {
            position: absolute;
            top: 15px;
            right: 20px;
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #92400e;
            opacity: 0.6;
            transition: opacity 0.2s;
        }
        
        .popup-close:hover {
            opacity: 1;
        }
        
        .bear-story h3 {
            color: #92400e;
            font-size: 1.5rem;
            margin-bottom: 15px;
            text-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }
        
        .bear-story p {
            color: #78350f;
            font-size: 1.1rem;
            line-height: 1.6;
            margin-bottom: 20px;
            max-width: 600px;
            margin-left: auto;
            margin-right: auto;
        }
        
        .bear-push-btn {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 1.2rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.4);
        }
        
        .bear-push-btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(245, 158, 11, 0.6);
        }
        
        .bear-hint {
            background: rgba(255, 255, 255, 0.8);
            border-radius: 15px;
            padding: 15px;
            margin-top: 20px;
            border: 2px solid #fbbf24;
        }
        
        .bear-hint p {
            margin: 0;
            font-size: 1rem;
            color: #92400e;
        }
        
        @media (max-width: 768px) {
            .viz-container {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .scenario-header {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }
            
            .legend {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üêª Timeline Analysis Prototype</h1>
        
        <!-- Scenario 1: Fear-mongering with sales pitch -->
        <div class="demo-card">
            <div class="scenario-header">
                <h2 class="scenario-title">Neighborhood Watch Alert</h2>
                <span class="correct-badge badge-emotion">Emotional Manipulation</span>
            </div>
            
            <div class="scenario-text">
                Posted in NextDoor by Jim Maxwell: URGENT - BE AWARE!!! üö®üö®üö® I saw a van driving slowly down Oak Street yesterday. It had out-of-state plates!!! This is EXACTLY how those trafficking rings operate that I read about on Facebook. They're probably scouting our children! I called 911 but they said 'driving slowly isn't a crime' - can you BELIEVE that?? The police won't protect us, so WE must protect ourselves! Everyone needs to buy security cameras NOW. My brother sells them - DM me for a 'neighbor discount.' SHARE THIS TO SAVE LIVES!!!
            </div>
            
            <div class="viz-container">
                <div class="radar-section">
                    <h3 class="section-title">Argument Fingerprint</h3>
                    <canvas id="radar1" width="280" height="240"></canvas>
                    <div class="radar-legend">
                        <div class="radar-bar logic-bar">
                            <div class="radar-bar-fill" style="width: 85%"></div>
                            <div class="bar-content">
                                <span class="bar-label">Logical Flaws</span>
                                <span class="bar-value">85%</span>
                            </div>
                        </div>
                        <div class="radar-bar emotion-bar">
                            <div class="radar-bar-fill" style="width: 95%"></div>
                            <div class="bar-content">
                                <span class="bar-label">Emotional</span>
                                <span class="bar-value">95%</span>
                            </div>
                        </div>
                        <div class="radar-bar balanced-bar">
                            <div class="radar-bar-fill" style="width: 5%"></div>
                            <div class="bar-content">
                                <span class="bar-label">Balanced</span>
                                <span class="bar-value">5%</span>
                            </div>
                        </div>
                        <div class="radar-bar agenda-bar">
                            <div class="radar-bar-fill" style="width: 85%"></div>
                            <div class="bar-content">
                                <span class="bar-label">Hidden Agenda</span>
                                <span class="bar-value">85%</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="timeline-section">
                    <h3 class="section-title">Language Evolution Timeline</h3>
                    <div style="position: relative; display: block;">
                        <canvas id="timeline1" width="600" height="300"></canvas>
                        <div class="bear-paw-icon" id="bear-paw-1" onclick="handleBearPawClick('timeline1')" title="üêª Runner Bear" style="background-image: url('images/bearpaw.svg'); background-size: cover; background-position: center;">
                        </div>
                        <div class="bear-flyout" id="bear-flyout-1">
                            <div class="bear-timer-bar">
                                <div class="bear-timer-fill" id="bear-timer-fill-1"></div>
                            </div>
                            <button onclick="giveBearPush('timeline1')" id="push-btn-1" class="bear-push-btn" style="width: 100%; font-size: 1.2rem; padding: 10px 8px; margin: 0; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; border: none; border-radius: 6px; font-weight: 700; cursor: pointer; box-shadow: 0 3px 8px rgba(59, 130, 246, 0.3); position: relative;">
                                <span style="position: absolute; left: 10px; top: 50%; transform: translateY(-50%) rotate(-15deg); font-size: 20px;">üêæ</span>
                                <span style="margin-left: 18px;">PUSH!</span>
                            </button>
                        </div>
                    </div>
                    <div class="dimension-toggles">
                        <button class="toggle-btn logic-toggle active" data-dimension="logic" onclick="toggleDimension('timeline1', 'logic')">
                            <span class="toggle-color logic-color"></span> Logical Flaws
                        </button>
                        <button class="toggle-btn emotion-toggle active" data-dimension="emotion" onclick="toggleDimension('timeline1', 'emotion')">
                            <span class="toggle-color emotion-color"></span> Emotional
                        </button>
                        <button class="toggle-btn balanced-toggle active" data-dimension="balanced" onclick="toggleDimension('timeline1', 'balanced')">
                            <span class="toggle-color balanced-color"></span> Balanced
                        </button>
                        <button class="toggle-btn agenda-toggle active" data-dimension="agenda" onclick="toggleDimension('timeline1', 'agenda')">
                            <span class="toggle-color agenda-color"></span> Agenda
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="info-box">
                <div class="info-title">What the timeline shows:</div>
                Early fear spikes with "URGENT!!! üö®", logic issues peak with Facebook speculation, then agenda surges with camera sales pitch.
            </div>
            
            <div class="explanatory-section">
                <h3 class="explanation-title">üéØ Why This Analysis Matters</h3>
                <div class="explanation-content">
                    <p><strong>The Timeline Reveals Manipulation Patterns:</strong> This scenario demonstrates classic fear-mongering tactics - starting with urgent language to grab attention, escalating with unsupported claims from social media, and ending with a sales pitch disguised as community safety.</p>
                    
                    <p><strong>How Rankings Work:</strong> Responses that identify the <span class="highlight-emotion">emotional manipulation</span> score highest because they recognize the primary tactic being used. While there are also <span class="highlight-logic">logical flaws</span> and a hidden <span class="highlight-agenda">agenda</span>, the emotional fear-mongering is the main driver of this message's persuasive power. Note the very low <span class="highlight-balanced">balanced approach</span> score - this message completely lacks nuance or multiple perspectives.</p>
                    
                    <p><strong>Real-World Application:</strong> When you see similar patterns - urgent warnings leading to product sales - you can recognize the manipulation before being influenced by it.</p>
                </div>
            </div>
        </div>
        
        <!-- Scenario 2: Balanced research -->
        <div class="demo-card">
            <div class="scenario-header">
                <h2 class="scenario-title">MIT Remote Work Study</h2>
                <span class="correct-badge badge-balanced">Well-Balanced</span>
            </div>
            
            <div class="scenario-text">
                MIT researchers concluded a 5-year study on remote work productivity: 'We tracked 2,400 employees across 15 companies. Overall productivity increased 13% for remote workers, but results varied by role. Creative tasks showed 22% improvement, while collaborative projects decreased 8% in efficiency. Employee satisfaction rose 31%, sick days dropped 25%. However, junior employees reported 40% less mentorship. Companies saving on office space averaged $11,000 per employee annually.'
            </div>
            
            <div class="viz-container">
                <div class="radar-section">
                    <h3 class="section-title">Argument Fingerprint</h3>
                    <canvas id="radar2" width="280" height="240"></canvas>
                    <div class="radar-legend">
                        <div class="radar-bar logic-bar">
                            <div class="radar-bar-fill" style="width: 20%"></div>
                            <div class="bar-content">
                                <span class="bar-label">Logical Flaws</span>
                                <span class="bar-value">20%</span>
                            </div>
                        </div>
                        <div class="radar-bar emotion-bar">
                            <div class="radar-bar-fill" style="width: 15%"></div>
                            <div class="bar-content">
                                <span class="bar-label">Emotional</span>
                                <span class="bar-value">15%</span>
                            </div>
                        </div>
                        <div class="radar-bar balanced-bar">
                            <div class="radar-bar-fill" style="width: 100%"></div>
                            <div class="bar-content">
                                <span class="bar-label">Balanced</span>
                                <span class="bar-value">100%</span>
                            </div>
                        </div>
                        <div class="radar-bar agenda-bar">
                            <div class="radar-bar-fill" style="width: 5%"></div>
                            <div class="bar-content">
                                <span class="bar-label">Hidden Agenda</span>
                                <span class="bar-value">5%</span>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="timeline-section">
                    <h3 class="section-title">Language Evolution Timeline</h3>
                    <div style="position: relative; display: block;">
                        <canvas id="timeline2" width="600" height="300"></canvas>
                        <div class="bear-paw-icon" id="bear-paw-2" onclick="handleBearPawClick('timeline2')" title="üêª Runner Bear" style="background-image: url('images/bearpaw.svg'); background-size: cover; background-position: center;">
                        </div>
                        <div class="bear-flyout" id="bear-flyout-2">
                            <div class="bear-timer-bar">
                                <div class="bear-timer-fill" id="bear-timer-fill-2"></div>
                            </div>
                            <button onclick="giveBearPush('timeline2')" id="push-btn-2" class="bear-push-btn" style="width: 100%; font-size: 1.2rem; padding: 10px 8px; margin: 0; background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%); color: white; border: none; border-radius: 6px; font-weight: 700; cursor: pointer; box-shadow: 0 3px 8px rgba(59, 130, 246, 0.3); position: relative;">
                                <span style="position: absolute; left: 10px; top: 50%; transform: translateY(-50%) rotate(-15deg); font-size: 20px;">üêæ</span>
                                <span style="margin-left: 18px;">PUSH!</span>
                            </button>
                        </div>
                    </div>
                    <div class="dimension-toggles">
                        <button class="toggle-btn logic-toggle active" data-dimension="logic" onclick="toggleDimension('timeline2', 'logic')">
                            <span class="toggle-color logic-color"></span> Logical Flaws
                        </button>
                        <button class="toggle-btn emotion-toggle active" data-dimension="emotion" onclick="toggleDimension('timeline2', 'emotion')">
                            <span class="toggle-color emotion-color"></span> Emotional
                        </button>
                        <button class="toggle-btn balanced-toggle active" data-dimension="balanced" onclick="toggleDimension('timeline2', 'balanced')">
                            <span class="toggle-color balanced-color"></span> Balanced
                        </button>
                        <button class="toggle-btn agenda-toggle active" data-dimension="agenda" onclick="toggleDimension('timeline2', 'agenda')">
                            <span class="toggle-color agenda-color"></span> Agenda
                        </button>
                    </div>
                </div>
            </div>
            
            <div class="info-box">
                <div class="info-title">What the timeline shows:</div>
                Consistent balanced language throughout with qualifying words like "but", "however", "varied" maintaining professional tone.
            </div>
            
            <div class="explanatory-section">
                <h3 class="explanation-title">üéØ Why This Analysis Matters</h3>
                <div class="explanation-content">
                    <p><strong>The Timeline Shows Quality Research:</strong> This MIT study demonstrates how credible information is presented - with specific data, acknowledgment of limitations, and balanced reporting of both positive and negative findings.</p>
                    
                    <p><strong>How Rankings Work:</strong> <span class="highlight-balanced">Balanced</span> responses score highest here because they recognize the nuanced, evidence-based approach. The low scores in <span class="highlight-emotion">emotional manipulation</span> and <span class="highlight-agenda">hidden agenda</span> indicate authentic research communication. The moderate <span class="highlight-logic">logical flaws</span> score reflects minor limitations, not manipulation - true research acknowledges its boundaries.</p>
                    
                    <p><strong>Real-World Application:</strong> Look for this pattern in quality sources - specific numbers, contradictory findings included, and acknowledgment of complexity rather than simple answers.</p>
                    
                    <p><strong>True Balance vs False Equivalency:</strong> This example shows genuine balance through proportional evidence (22% improvement vs 8% decrease reflects actual measured differences). False balance would present vastly unequal positions as equivalent - like giving equal weight to one Facebook post versus thousands of scientific studies.</p>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <button onclick="animateCharts()">üé¨ Animate All</button>
            <button onclick="toggleAnnotations()">üè∑Ô∏è Toggle Labels</button>
            <button onclick="resetCharts()">üîÑ Reset</button>
            <button onclick="toggleSound()" id="sound-toggle">üîá Sound Off</button>
        </div>
        
        <!-- Hidden mini-game overlay - appears when exactly one dimension is selected -->
        <div class="mini-game-overlay" id="mini-game-overlay">
            <div class="mini-game-popup">
                <button class="popup-close" onclick="closeMiniGame()">√ó</button>
                <div class="bear-story">
                    <h3>üêª Secret Discovery!</h3>
                    <p>Wow! You found Runner Bear! He's been waiting for curious explorers like you. 
                    Watch him roll along your chosen dimension - he loves racing down emotional peaks 
                    and struggling up logical hills!</p>
                    <button onclick="giveBearPush()" class="bear-push-btn">üêæ Give Bear a Push!</button>
                    <div class="bear-hint" id="bear-hint" style="display: none;">
                        <p>üéâ <strong>Bear says:</strong> Thanks for the boost! Try switching to different dimensions 
                        to see how I handle various terrains! Each one feels totally different! üé¢</p>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color logic-color"></div>
                <span><strong>Logical Flaws:</strong> Fallacies, weak evidence</span>
            </div>
            <div class="legend-item">
                <div class="legend-color emotion-color"></div>
                <span><strong>Emotional Manipulation:</strong> Fear, guilt, urgency</span>
            </div>
            <div class="legend-item">
                <div class="legend-color balanced-color"></div>
                <span><strong>Balanced Approach:</strong> Nuanced, fair</span>
            </div>
            <div class="legend-item">
                <div class="legend-color agenda-color"></div>
                <span><strong>Hidden Agenda:</strong> Sales, profit motive</span>
            </div>
        </div>
    </div>

    <script>
        // ===== RADAR CHART IMPLEMENTATION =====
        class RadarChart {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.colors = {
                    logic: '#3b82f6',
                    emotion: '#ec4899',
                    balanced: '#10b981',
                    agenda: '#f59e0b'
                };
            }
            
            draw(scores) {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const radius = 100;
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Background circles
                this.ctx.strokeStyle = '#e5e7eb';
                this.ctx.lineWidth = 1;
                for (let i = 1; i <= 4; i++) {
                    this.ctx.beginPath();
                    this.ctx.arc(centerX, centerY, radius * i / 4, 0, 2 * Math.PI);
                    this.ctx.stroke();
                }
                
                // Axes
                this.ctx.strokeStyle = '#d1d5db';
                this.ctx.lineWidth = 2;
                const labels = ['Logical Flaws', 'Emotional', 'Balanced', 'Hidden Agenda'];
                for (let i = 0; i < 4; i++) {
                    const angle = -Math.PI / 2 + i * Math.PI / 2;
                    const x = centerX + radius * Math.cos(angle);
                    const y = centerY + radius * Math.sin(angle);
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(centerX, centerY);
                    this.ctx.lineTo(x, y);
                    this.ctx.stroke();
                    
                    // Don't draw labels on canvas anymore - using bar chart below
                }
                
                // Data area
                const values = [scores.logic, scores.emotion, scores.balanced, scores.agenda];
                this.ctx.beginPath();
                for (let i = 0; i < 4; i++) {
                    const angle = -Math.PI / 2 + i * Math.PI / 2;
                    const value = values[i] / 100;
                    const x = centerX + radius * value * Math.cos(angle);
                    const y = centerY + radius * value * Math.sin(angle);
                    
                    if (i === 0) this.ctx.moveTo(x, y);
                    else this.ctx.lineTo(x, y);
                }
                this.ctx.closePath();
                
                // Fill
                this.ctx.fillStyle = 'rgba(102, 126, 234, 0.2)';
                this.ctx.fill();
                this.ctx.strokeStyle = '#667eea';
                this.ctx.lineWidth = 3;
                this.ctx.stroke();
                
                // Points
                for (let i = 0; i < 4; i++) {
                    const angle = -Math.PI / 2 + i * Math.PI / 2;
                    const value = values[i] / 100;
                    const x = centerX + radius * value * Math.cos(angle);
                    const y = centerY + radius * value * Math.sin(angle);
                    
                    this.ctx.beginPath();
                    this.ctx.arc(x, y, 5, 0, 2 * Math.PI);
                    this.ctx.fillStyle = Object.values(this.colors)[i];
                    this.ctx.fill();
                    this.ctx.strokeStyle = 'white';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                }
            }
        }
        
        // ===== TIMELINE CHART IMPLEMENTATION =====
        class TimelineChart {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.colors = {
                    logic: '#3b82f6',
                    emotion: '#ec4899',
                    balanced: '#10b981',
                    agenda: '#f59e0b'
                };
                this.showAnnotations = true;
                this.hoveredDimension = null;
                this.visibleDimensions = {
                    logic: true,
                    emotion: true,
                    balanced: true,
                    agenda: true
                };
                this.highlightedDimension = null;
                this.sparkleInterval = null;
                this.rippleAnimation = null;
                this.rippleTime = 0;
                this.setupInteractions();
                this.startRippleAnimation();
            }
            
            setupInteractions() {
                this.canvas.addEventListener('mousemove', (e) => {
                    this.handleMouseMove(e);
                });
                
                this.canvas.addEventListener('mouseleave', () => {
                    this.hoveredDimension = null;
                    this.redraw();
                });
                
                this.canvas.addEventListener('click', (e) => {
                    this.handleClick(e);
                });
            }
            
            handleMouseMove(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                // Find closest point to determine which dimension is being hovered
                if (this.currentData) {
                    this.hoveredDimension = this.findClosestDimension(x, y);
                    this.redraw();
                }
            }
            
            handleClick(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                
                if (this.currentData) {
                    const clickedDimension = this.findClosestDimension(x, y);
                    if (clickedDimension) {
                        this.highlightTextForDimension(clickedDimension);
                    }
                }
            }
            
            findClosestDimension(mouseX, mouseY) {
                if (!this.currentData) return null;
                
                const padding = 50;
                const width = this.canvas.width - padding * 2;
                const height = this.canvas.height - padding * 2;
                
                let closestDimension = null;
                let minDistance = Infinity;
                
                Object.keys(this.colors).forEach(dimension => {
                    this.currentData.forEach(point => {
                        const x = padding + point.position * width;
                        const y = padding + height - (point.scores[dimension] / 100 * height);
                        
                        const distance = Math.sqrt((mouseX - x) ** 2 + (mouseY - y) ** 2);
                        
                        if (distance < 30 && distance < minDistance) { // 30px hover radius
                            minDistance = distance;
                            closestDimension = dimension;
                        }
                    });
                });
                
                return closestDimension;
            }
            
            highlightTextForDimension(dimension) {
                // Find the scenario text element and highlight keywords for this dimension
                const scenarioCards = document.querySelectorAll('.scenario-text');
                scenarioCards.forEach((textElement, index) => {
                    if (index === 0 && this.canvas.id === 'timeline1') {
                        this.highlightScenarioText(textElement, dimension, this.currentKeywords);
                    } else if (index === 1 && this.canvas.id === 'timeline2') {
                        this.highlightScenarioText(textElement, dimension, this.currentKeywords);
                    }
                });
            }
            
            highlightScenarioText(textElement, dimension, keywords) {
                if (!keywords || !keywords[dimension]) return;
                
                const colorMap = {
                    logic: { color: '#3b82f6', bgColor: '#dbeafe' },
                    emotion: { color: '#ec4899', bgColor: '#fce7f3' },
                    balanced: { color: '#10b981', bgColor: '#d1fae5' },
                    agenda: { color: '#f59e0b', bgColor: '#fef3c7' }
                };
                
                const colors = colorMap[dimension];
                const keywordList = keywords[dimension];
                
                // Reset text first
                const originalText = textElement.getAttribute('data-original-text') || textElement.textContent;
                textElement.setAttribute('data-original-text', originalText);
                
                // Sort keywords by length (longer first)
                keywordList.sort((a, b) => b.length - a.length);
                
                // Create regex and highlight
                const regex = new RegExp('(' + keywordList.map(keyword => 
                    keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
                ).join('|') + ')', 'gi');
                
                const highlightedText = originalText.replace(regex, match => 
                    `<span style="background-color: ${colors.bgColor}; color: ${colors.color}; padding: 2px 4px; border-radius: 4px; font-weight: 600;">${match}</span>`
                );
                
                textElement.innerHTML = highlightedText;
                
                // Auto-clear highlight after 3 seconds
                setTimeout(() => {
                    textElement.innerHTML = originalText;
                }, 3000);
            }
            
            analyzeText(text, keywords) {
                const sentences = text.match(/[^.!?]+[.!?]+/g) || [text];
                const data = [];
                
                sentences.forEach((sentence, index) => {
                    const scores = {
                        logic: this.scoreKeywords(sentence, keywords.logic),
                        emotion: this.scoreKeywords(sentence, keywords.emotion),
                        balanced: this.scoreKeywords(sentence, keywords.balanced),
                        agenda: this.scoreKeywords(sentence, keywords.agenda)
                    };
                    
                    data.push({
                        sentence: sentence.trim(),
                        position: index / Math.max(1, sentences.length - 1),
                        scores
                    });
                });
                
                return data;
            }
            
            scoreKeywords(sentence, keywords) {
                let score = 0;
                keywords.forEach(keyword => {
                    const regex = new RegExp(keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
                    const matches = sentence.match(regex);
                    if (matches) {
                        score += matches.length * Math.min(10, keyword.length);
                    }
                });
                return Math.min(100, score * 2);
            }
            
            draw(text, keywords) {
                this.currentData = this.analyzeText(text, keywords);
                this.currentKeywords = keywords;
                this.redraw();
            }
            
            redraw() {
                if (!this.currentData) return;
                
                const data = this.currentData;
                const keywords = this.currentKeywords;
                const padding = 50;
                const width = this.canvas.width - padding * 2;
                const height = this.canvas.height - padding * 2;
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Background grid
                this.ctx.strokeStyle = '#f3f4f6';
                this.ctx.lineWidth = 1;
                for (let i = 0; i <= 4; i++) {
                    const y = padding + height - (height * i / 4);
                    this.ctx.beginPath();
                    this.ctx.moveTo(padding, y);
                    this.ctx.lineTo(padding + width, y);
                    this.ctx.stroke();
                    
                    // Y labels
                    this.ctx.fillStyle = '#6b7280';
                    this.ctx.font = '11px sans-serif';
                    this.ctx.textAlign = 'right';
                    this.ctx.fillText((i * 25) + '%', padding - 5, y + 3);
                }
                
                // Count visible dimensions
                const visibleDimensions = Object.keys(this.colors).filter(d => this.visibleDimensions[d]);
                
                // Draw lines for each dimension with fade effect
                Object.keys(this.colors).forEach(dimension => {
                    if (this.visibleDimensions[dimension]) {
                        const shouldFade = this.hoveredDimension && this.hoveredDimension !== dimension;
                        this.drawLine(data, dimension, padding, width, height, shouldFade);
                    }
                });
                
                // Handle character animation - only during active game
                if (visibleDimensions.length === 1 && bearGameState.gameActive) {
                    // Start sparkles if not running
                    if (!this.sparkleInterval) {
                        this.startSparkles(data, visibleDimensions[0], padding, width, height);
                    }
                    
                    // Draw character if data exists
                    if (this.characterData && this.characterData.position !== undefined) {
                        const pos = this.characterData.position;
                        const dataIndex = Math.floor(pos * (data.length - 1));
                        const nextIndex = Math.min(dataIndex + 1, data.length - 1);
                        const localProgress = (pos * (data.length - 1)) % 1;
                        
                        const currentPoint = data[dataIndex];
                        const nextPoint = data[nextIndex];
                        const currentY = currentPoint.scores[visibleDimensions[0]];
                        const nextY = nextPoint.scores[visibleDimensions[0]];
                        const interpolatedY = currentY + (nextY - currentY) * localProgress;
                        
                        const x = padding + pos * width;
                        const y = padding + height - (interpolatedY / 100 * height);
                        
                        // Calculate slope angle and curvature for proper ground following
                        const prevIndex = Math.max(dataIndex - 1, 0);
                        const futureIndex = Math.min(dataIndex + 2, data.length - 1);
                        
                        const prevPoint = data[prevIndex];
                        const futurePoint = data[futureIndex];
                        
                        const prevX = padding + prevPoint.position * width;
                        const currentX = padding + currentPoint.position * width;
                        const nextX = padding + nextPoint.position * width;
                        const futureX = padding + futurePoint.position * width;
                        
                        const prevY = padding + height - (prevPoint.scores[visibleDimensions[0]] / 100 * height);
                        const currentLineY = padding + height - (currentY / 100 * height);
                        const nextLineY = padding + height - (nextY / 100 * height);
                        const futureY = padding + height - (futurePoint.scores[visibleDimensions[0]] / 100 * height);
                        
                        // Use cubic interpolation for smoother following
                        const t = localProgress;
                        const t2 = t * t;
                        const t3 = t2 * t;
                        
                        // Catmull-Rom spline for smooth curve following
                        const interpolatedX = 0.5 * (
                            (2 * currentX) +
                            (-prevX + nextX) * t +
                            (2 * prevX - 5 * currentX + 4 * nextX - futureX) * t2 +
                            (-prevX + 3 * currentX - 3 * nextX + futureX) * t3
                        );
                        
                        const interpolatedLineY = 0.5 * (
                            (2 * currentLineY) +
                            (-prevY + nextLineY) * t +
                            (2 * prevY - 5 * currentLineY + 4 * nextLineY - futureY) * t2 +
                            (-prevY + 3 * currentLineY - 3 * nextLineY + futureY) * t3
                        );
                        
                        // Calculate slope from interpolated curve
                        const deltaX = 0.5 * (
                            (-prevX + nextX) +
                            2 * (2 * prevX - 5 * currentX + 4 * nextX - futureX) * t +
                            3 * (-prevX + 3 * currentX - 3 * nextX + futureX) * t2
                        );
                        
                        const deltaY = 0.5 * (
                            (-prevY + nextLineY) +
                            2 * (2 * prevY - 5 * currentLineY + 4 * nextLineY - futureY) * t +
                            3 * (-prevY + 3 * currentLineY - 3 * nextLineY + futureY) * t2
                        );
                        
                        const slopeAngle = Math.atan2(deltaY, deltaX);
                        
                        // Use the smoothly interpolated position instead of linear
                        const smoothX = interpolatedX;
                        const smoothY = interpolatedLineY;
                        
                        this.drawCharacter(smoothX, smoothY, this.characterData.emoji, this.characterData.state || 'rolling', this.characterData.speed || 0, slopeAngle);
                    }
                } else {
                    // Stop sparkles if game not active or multiple dimensions visible
                    this.stopSparkles();
                }
                
                if (!this.sparkleInterval) {
                    // Add ripple effects only when character not active
                    this.drawRipples(data, padding, width, height);
                }
                
                // Annotations
                if (this.showAnnotations) {
                    this.drawAnnotations(data, padding, width, height, keywords);
                }
                
                // X-axis label
                this.ctx.fillStyle = '#374151';
                this.ctx.font = '12px sans-serif';
                this.ctx.textAlign = 'center';
                this.ctx.fillText('Reading Progress ‚Üí', padding + width / 2, this.canvas.height - 10);
            }
            
            drawLine(data, dimension, padding, width, height, shouldFade = false) {
                if (data.length < 2) return;
                
                // Apply fade effect if needed
                const baseColor = this.colors[dimension];
                const alpha = shouldFade ? 0.2 : 1.0;
                this.ctx.strokeStyle = this.hexToRgba(baseColor, alpha);
                this.ctx.lineWidth = shouldFade ? 1.5 : 2.5;
                this.ctx.lineCap = 'round';
                
                // Create smooth curve using Bezier curves
                this.ctx.beginPath();
                
                const points = data.map(point => ({
                    x: padding + point.position * width,
                    y: padding + height - (point.scores[dimension] / 100 * height)
                }));
                
                // Start at first point
                this.ctx.moveTo(points[0].x, points[0].y);
                
                // Create smooth curves between points
                for (let i = 1; i < points.length; i++) {
                    const prevPoint = points[i - 1];
                    const currentPoint = points[i];
                    const nextPoint = points[i + 1];
                    
                    if (i === points.length - 1) {
                        // Last segment - just draw to the point
                        this.ctx.lineTo(currentPoint.x, currentPoint.y);
                    } else {
                        // Calculate control points for smooth curve
                        const tension = 0.3;
                        const cp1x = prevPoint.x + (currentPoint.x - prevPoint.x) * tension;
                        const cp1y = prevPoint.y + (currentPoint.y - prevPoint.y) * tension;
                        const cp2x = currentPoint.x - (nextPoint.x - prevPoint.x) * tension;
                        const cp2y = currentPoint.y - (nextPoint.y - prevPoint.y) * tension;
                        
                        this.ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, currentPoint.x, currentPoint.y);
                    }
                }
                
                this.ctx.stroke();
                
                // Draw points
                data.forEach(point => {
                    if (point.scores[dimension] > 15) {
                        const x = padding + point.position * width;
                        const y = padding + height - (point.scores[dimension] / 100 * height);
                        
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, shouldFade ? 2 : 3, 0, 2 * Math.PI);
                        this.ctx.fillStyle = this.hexToRgba(baseColor, alpha);
                        this.ctx.fill();
                    }
                });
            }
            
            hexToRgba(hex, alpha) {
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
            }
            
            drawAnnotations(data, padding, width, height, keywords) {
                // Find highest peaks for visible dimensions
                const peaks = {};
                Object.keys(this.colors).forEach(dimension => {
                    if (!this.visibleDimensions[dimension]) return;
                    
                    let maxScore = 0;
                    let maxIndex = 0;
                    
                    data.forEach((point, index) => {
                        if (point.scores[dimension] > maxScore) {
                            maxScore = point.scores[dimension];
                            maxIndex = index;
                        }
                    });
                    
                    if (maxScore > 30) { // Only significant peaks
                        peaks[dimension] = { index: maxIndex, score: maxScore };
                    }
                });
                
                // Draw triangle markers for peaks
                Object.entries(peaks).forEach(([dimension, peak]) => {
                    const point = data[peak.index];
                    const x = padding + point.position * width;
                    const y = padding + height - (peak.score / 100 * height);
                    
                    // Draw downward-pointing triangle
                    this.ctx.save();
                    this.ctx.fillStyle = this.colors[dimension];
                    this.ctx.strokeStyle = 'white';
                    this.ctx.lineWidth = 2;
                    
                    const triangleSize = 8;
                    const triangleY = y - 15;
                    
                    // Draw triangle
                    this.ctx.beginPath();
                    this.ctx.moveTo(x, triangleY + triangleSize);
                    this.ctx.lineTo(x - triangleSize * 0.7, triangleY - triangleSize * 0.5);
                    this.ctx.lineTo(x + triangleSize * 0.7, triangleY - triangleSize * 0.5);
                    this.ctx.closePath();
                    
                    // White stroke for visibility
                    this.ctx.stroke();
                    this.ctx.fill();
                    
                    this.ctx.restore();
                });
            }
            
            startSparkles(data, dimension, padding, width, height) {
                if (this.sparkleInterval) return; // Already running
                
                // Stop ripple animation to reduce conflicts
                if (this.rippleAnimation) {
                    clearInterval(this.rippleAnimation);
                    this.rippleAnimation = null;
                }
                
                let sparklePosition = 0;
                let velocity = 0;
                let characterState = 'rolling';
                let lastSlope = 0;
                
                // Character colors based on dimension - all custom balls now
                const characters = {
                    logic: 'blue-ball',
                    emotion: 'pink-ball', 
                    balanced: 'green-ball',
                    agenda: 'orange-ball'
                };
                
                // Sound effects (using Web Audio API)
                let audioContext;
                try {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                } catch (e) {
                    console.log('Audio not available');
                }
                
                const playSound = (type) => {
                    if (!window.soundEnabled || !audioContext) return;
                    
                    try {
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        if (type === 'climb') {
                            // Low grunt sound
                            oscillator.frequency.setValueAtTime(100, audioContext.currentTime);
                            oscillator.frequency.exponentialRampToValueAtTime(80, audioContext.currentTime + 0.2);
                            gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                        } else if (type === 'descend') {
                            // High "wheee" sound
                            oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                            oscillator.frequency.exponentialRampToValueAtTime(400, audioContext.currentTime + 0.3);
                            gainNode.gain.setValueAtTime(0.05, audioContext.currentTime);
                            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);
                        }
                        
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + 0.3);
                    } catch (e) {
                        // Silently fail if audio context issues
                    }
                };
                
                // Store character data for drawing
                this.characterData = {
                    dimension: dimension,
                    emoji: characters[dimension]
                };
                
                this.sparkleInterval = setInterval(() => {
                    // Don't redraw entire chart, just update character
                    
                    // Find current and next data points
                    const dataIndex = Math.floor(sparklePosition * (data.length - 1));
                    const nextIndex = Math.min(dataIndex + 1, data.length - 1);
                    const localProgress = (sparklePosition * (data.length - 1)) % 1;
                    
                    // Get current and next Y values
                    const currentPoint = data[dataIndex];
                    const nextPoint = data[nextIndex];
                    const currentY = currentPoint.scores[dimension];
                    const nextY = nextPoint.scores[dimension];
                    
                    // Calculate slope (vertical change)
                    const slope = nextY - currentY;
                    const isClimbing = slope > 0;
                    const isDescending = slope < 0;
                    const steepness = Math.abs(slope) / 100; // Normalize to 0-1
                    
                    // Physics constants - SOLUTION 1: MOMENTUM CONSERVATION
                    const gravity = 0.0003;
                    const friction = 0.98;    // More friction to slow things down
                    const pushForce = 0.0002; // Less aggressive push
                    
                    // SOLUTION 1: Add momentum conservation for peaks
                    const momentumConservation = 0.85; // Preserve 85% of momentum at peaks
                    
                    // Debug: Log what we're seeing (uncomment to debug)
                    // console.log(`Slope: ${slope.toFixed(2)}, Steepness: ${steepness.toFixed(2)}, Climbing: ${isClimbing}, Velocity: ${velocity.toFixed(4)}`);
                    
                    if (isClimbing) {
                        // Much stronger uphill resistance
                        velocity *= (1 - steepness * 0.3); // Up to 30% speed reduction
                        velocity -= gravity * steepness * 5; // Strong gravity resistance
                        
                        // Minimal push when climbing steep hills
                        if (steepness < 0.5) {
                            velocity += pushForce * 0.5;
                        }
                        
                        // Play climb sound occasionally
                        if (Math.abs(slope - lastSlope) > 10 && Math.random() < 0.1) {
                            playSound('climb');
                        }
                    } else if (isDescending) {
                        // Apply downhill acceleration - but cap it
                        velocity += gravity * steepness * 0.8;
                        
                        // Play descend sound on steep drops
                        if (steepness > 0.3 && Math.abs(slope - lastSlope) > 15 && Math.random() < 0.2) {
                            playSound('descend');
                        }
                    } else {
                        // Flat ground - maintain steady but slow speed
                        velocity += pushForce * 0.8;
                    }
                    
                    // Apply friction and tighter speed limits
                    velocity *= friction;
                    velocity = Math.max(0.0005, Math.min(0.008, velocity)); // Tighter speed range
                    
                    // Check for pending boost from bear push button
                    if (this.characterData && this.characterData.pendingBoost) {
                        velocity += this.characterData.pendingBoost;
                        // Clear the boost so it only applies once
                        this.characterData.pendingBoost = null;
                        // Play a boost sound if available
                        if (audioContext && window.soundEnabled) {
                            playSound('descend'); // Use the happy "wheee" sound for boost
                        }
                    }
                    
                    // Update position
                    sparklePosition = (sparklePosition + velocity) % 1;
                    
                    // Determine character state based on movement
                    if (isClimbing && steepness > 0.5) {
                        characterState = 'struggling';
                    } else if (isDescending && steepness > 0.3) {
                        characterState = 'zooming';
                    } else {
                        characterState = 'rolling';
                    }
                    
                    // Interpolate position
                    const interpolatedY = currentY + (nextY - currentY) * localProgress;
                    
                    const x = padding + sparklePosition * width;
                    const y = padding + height - (interpolatedY / 100 * height);
                    
                    // Update character data
                    this.characterData.position = sparklePosition;
                    this.characterData.state = characterState;
                    this.characterData.speed = velocity * 100;
                    
                    // Only redraw the chart
                    this.redraw();
                    
                    lastSlope = slope;
                }, 100); // 10 FPS for smoother perception
            }
            
            stopSparkles() {
                if (this.sparkleInterval) {
                    clearInterval(this.sparkleInterval);
                    this.sparkleInterval = null;
                    this.characterData = null; // Clear character data
                    this.redraw(); // Clear any remaining sparkles
                    
                    // Restart ripple animation
                    this.startRippleAnimation();
                }
            }
            
            drawCharacter(x, y, emoji, state, speed, slopeAngle = 0) {
                this.ctx.save();
                
                // Calculate proper offset perpendicular to slope - smaller balls
                const charRadius = 10; // Smaller character radius
                const offsetX = Math.sin(slopeAngle) * charRadius;
                const offsetY = -Math.cos(slopeAngle) * charRadius;
                
                // Add some visual effects based on state
                let bounce = 0;
                let tilt = 0;
                let squish = 1;
                
                if (state === 'struggling') {
                    // Wobble effect when climbing
                    bounce = Math.sin(Date.now() * 0.005) * 2;
                    tilt = Math.sin(Date.now() * 0.008) * 0.1 + slopeAngle * 0.3; // Lean into slope
                    squish = 0.9 + Math.sin(Date.now() * 0.01) * 0.1;
                } else if (state === 'zooming') {
                    // Stretch effect when descending fast
                    squish = 1 + speed * 0.2;
                    tilt = slopeAngle * 0.5; // Lean with slope when zooming
                } else {
                    // Gentle bounce when rolling, slight tilt with slope
                    bounce = Math.sin(Date.now() * 0.003) * 1;
                    tilt = slopeAngle * 0.2;
                }
                
                // Apply transformations - offset perpendicular to slope
                this.ctx.translate(x + offsetX, y + offsetY + bounce);
                this.ctx.rotate(tilt);
                this.ctx.scale(1, squish);
                
                // No shadow - keeping it light as requested
                
                // Draw custom character balls with paw imprints
                this.ctx.globalAlpha = 1;
                const ballRadius = 10; // Smaller ball size
                
                // Choose ball color based on dimension
                let ballColor, ballHighlight;
                switch(emoji) {
                    case 'blue-ball':
                        ballColor = '#3b82f6'; // Blue
                        ballHighlight = '#60a5fa';
                        break;
                    case 'pink-ball':
                        ballColor = '#ec4899'; // Pink (replacing heart)
                        ballHighlight = '#f472b6';
                        break;
                    case 'green-ball':
                        ballColor = '#10b981'; // Green
                        ballHighlight = '#34d399';
                        break;
                    case 'orange-ball':
                        ballColor = '#f59e0b'; // Orange
                        ballHighlight = '#fbbf24';
                        break;
                    default:
                        ballColor = '#6b7280';
                        ballHighlight = '#9ca3af';
                }
                
                // Draw main ball
                this.ctx.fillStyle = ballColor;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, ballRadius, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Calculate rolling rotation based on position
                const rollRotation = (this.characterData.position || 0) * Math.PI * 8; // 4 full rotations per journey
                
                // Add rolling highlight that moves around the ball
                this.ctx.save();
                this.ctx.rotate(rollRotation);
                this.ctx.fillStyle = ballHighlight;
                this.ctx.beginPath();
                this.ctx.arc(-3, -3, 3, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Add a secondary rolling element (like a stripe or dot)
                this.ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                this.ctx.beginPath();
                this.ctx.arc(0, -6, 1.5, 0, Math.PI * 2);
                this.ctx.fill();
                this.ctx.restore();
                
                // Add subtle expression based on state
                this.ctx.font = '10px sans-serif';
                this.ctx.globalAlpha = 0.7; // Make it more subtle
                if (state === 'struggling' && Math.random() < 0.3) { // Only show occasionally
                    this.ctx.fillText('üí®', 8, -12);
                } else if (state === 'zooming' && speed > 3) { // Only when really fast
                    this.ctx.fillText('üí®', -8, -12);
                }
                
                this.ctx.restore();
            }
            
            startRippleAnimation() {
                if (this.rippleAnimation) return;
                
                this.rippleAnimation = setInterval(() => {
                    this.rippleTime = (this.rippleTime + 0.015) % 1;
                    this.redraw();
                }, 50);
            }
            
            drawRipples(data, padding, width, height) {
                // Find high-intensity points across all visible dimensions
                const ripplePoints = [];
                
                Object.keys(this.colors).forEach(dimension => {
                    if (!this.visibleDimensions[dimension]) return;
                    
                    data.forEach((point, index) => {
                        if (point.scores[dimension] > 70) { // High intensity threshold
                            const x = padding + point.position * width;
                            const y = padding + height - (point.scores[dimension] / 100 * height);
                            
                            ripplePoints.push({
                                x: x,
                                y: y,
                                intensity: point.scores[dimension],
                                color: this.colors[dimension],
                                dimension: dimension,
                                index: index
                            });
                        }
                    });
                });
                
                // Draw ripples
                ripplePoints.forEach((point, pointIndex) => {
                    this.ctx.save();
                    
                    // Create multiple expanding circles with phase offset per point
                    for (let i = 0; i < 3; i++) {
                        const phaseOffset = (point.index * 0.2) % 1;
                        const ripplePhase = (this.rippleTime + i * 0.3 + phaseOffset) % 1;
                        const rippleRadius = ripplePhase * 30;
                        const rippleAlpha = (1 - ripplePhase) * 0.2;
                        
                        this.ctx.beginPath();
                        this.ctx.arc(point.x, point.y, rippleRadius, 0, Math.PI * 2);
                        this.ctx.strokeStyle = point.color + Math.round(rippleAlpha * 255).toString(16).padStart(2, '0');
                        this.ctx.lineWidth = 1.5;
                        this.ctx.stroke();
                    }
                    
                    this.ctx.restore();
                });
            }
        }
        
        // Helper for rounded rectangles
        if (!CanvasRenderingContext2D.prototype.roundRect) {
            CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, r) {
                this.beginPath();
                this.moveTo(x + r, y);
                this.lineTo(x + w - r, y);
                this.quadraticCurveTo(x + w, y, x + w, y + r);
                this.lineTo(x + w, y + h - r);
                this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                this.lineTo(x + r, y + h);
                this.quadraticCurveTo(x, y + h, x, y + h - r);
                this.lineTo(x, y + r);
                this.quadraticCurveTo(x, y, x + r, y);
                this.closePath();
            };
        }
        
        // ===== DEMO DATA =====
        const scenarios = {
            neighborhood: {
                scores: { logic: 85, emotion: 95, balanced: 5, agenda: 85 },
                text: `Posted in NextDoor by Jim Maxwell: URGENT - BE AWARE!!! üö®üö®üö® I saw a van driving slowly down Oak Street yesterday. It had out-of-state plates!!! This is EXACTLY how those trafficking rings operate that I read about on Facebook. They're probably scouting our children! I called 911 but they said 'driving slowly isn't a crime' - can you BELIEVE that?? The police won't protect us, so WE must protect ourselves! Everyone needs to buy security cameras NOW. My brother sells them - DM me for a 'neighbor discount.' SHARE THIS TO SAVE LIVES!!!`,
                keywords: {
                    logic: ['EXACTLY how', 'Facebook', 'probably', 'BELIEVE'],
                    emotion: ['URGENT', 'BE AWARE', 'üö®', 'trafficking', 'our children', 'protect ourselves', 'SAVE LIVES'],
                    balanced: ['police said', 'driving slowly'],
                    agenda: ['buy security cameras', 'My brother sells', 'neighbor discount', 'DM me']
                }
            },
            mit: {
                scores: { logic: 20, emotion: 15, balanced: 100, agenda: 5 },
                text: `MIT researchers concluded a 5-year study on remote work productivity: 'We tracked 2,400 employees across 15 companies. Overall productivity increased 13% for remote workers, but results varied by role. Creative tasks showed 22% improvement, while collaborative projects decreased 8% in efficiency. Employee satisfaction rose 31%, sick days dropped 25%. However, junior employees reported 40% less mentorship. Companies saving on office space averaged $11,000 per employee annually.'`,
                keywords: {
                    logic: ['5-year study', '2,400 employees', '15 companies', 'tracked'],
                    emotion: ['satisfaction', 'improvement'],
                    balanced: ['Overall', 'but', 'However', 'varied by role', 'while'],
                    agenda: ['$11,000', 'saving']
                }
            }
        };
        
        // ===== INITIALIZE CHARTS =====
        const radar1 = new RadarChart('radar1');
        const radar2 = new RadarChart('radar2');
        const timeline1 = new TimelineChart('timeline1');
        const timeline2 = new TimelineChart('timeline2');
        
        // Draw initial charts
        function drawCharts() {
            radar1.draw(scenarios.neighborhood.scores);
            radar2.draw(scenarios.mit.scores);
            timeline1.draw(scenarios.neighborhood.text, scenarios.neighborhood.keywords);
            timeline2.draw(scenarios.mit.text, scenarios.mit.keywords);
        }
        
        // ===== CONTROLS =====
        function animateCharts() {
            // Simple animation - redraw with effect
            drawCharts();
        }
        
        function toggleAnnotations() {
            timeline1.showAnnotations = !timeline1.showAnnotations;
            timeline2.showAnnotations = !timeline2.showAnnotations;
            timeline1.draw(scenarios.neighborhood.text, scenarios.neighborhood.keywords);
            timeline2.draw(scenarios.mit.text, scenarios.mit.keywords);
        }
        
        function resetCharts() {
            drawCharts();
        }
        
        // Initial draw
        drawCharts();
        
        // Setup button interactions
        function setupButtonInteractions() {
            const allButtons = document.querySelectorAll('.toggle-btn');
            
            allButtons.forEach(btn => {
                // Hover handling for desktop
                if (window.matchMedia('(hover: hover)').matches) {
                    btn.addEventListener('mouseenter', function() {
                        if (this.classList.contains('active') && !this.classList.contains('highlight-mode')) {
                            const chartId = this.closest('.timeline-section').querySelector('canvas').id;
                            const dimension = this.dataset.dimension;
                            highlightScenarioTextTemporary(chartId, dimension);
                        }
                    });
                    
                    btn.addEventListener('mouseleave', function() {
                        clearTemporaryHighlights();
                    });
                }
            });
        }
        
        // Toggle dimension with tri-state logic
        function toggleDimension(chartId, dimension) {
            // Prevent dimension toggling during bear game
            if (bearGameState.gameActive) {
                console.log('Cannot toggle dimensions during Runner Bear game!');
                return;
            }
            
            let chart;
            let scenarioIndex;
            if (chartId === 'timeline1') {
                chart = timeline1;
                scenarioIndex = 0;
            } else if (chartId === 'timeline2') {
                chart = timeline2;
                scenarioIndex = 1;
            }
            
            if (!chart) return;
            
            const button = document.querySelector(`.timeline-section:has(#${chartId}) button[data-dimension="${dimension}"]`);
            if (!button) return;
            
            // Batch all DOM updates in a single animation frame
            requestAnimationFrame(() => {
                // Determine current state and cycle to next
                const isVisible = chart.visibleDimensions[dimension];
                const isHighlighted = chart.highlightedDimension === dimension;
                
                if (!isVisible) {
                    // State: OFF ‚Üí ON
                    chart.visibleDimensions[dimension] = true;
                    button.classList.add('active');
                    button.classList.remove('highlight-mode');
                    chart.highlightedDimension = null;
                } else if (!isHighlighted) {
                    // State: ON ‚Üí HIGHLIGHT
                    // Clear other highlights
                    clearAllHighlights();
                    chart.highlightedDimension = dimension;
                    button.classList.add('highlight-mode');
                    
                    // Delay text highlighting slightly to prevent simultaneous updates
                    setTimeout(() => {
                        highlightScenarioTextPersistent(scenarioIndex, dimension);
                    }, 10);
                } else {
                    // State: HIGHLIGHT ‚Üí OFF
                    chart.visibleDimensions[dimension] = false;
                    chart.highlightedDimension = null;
                    button.classList.remove('active', 'highlight-mode');
                    clearPersistentHighlights();
                }
                
                // Mini-game now only triggered by paw icon clicks
                
                // Redraw chart after DOM updates
                chart.redraw();
            });
        }
        
        // Highlight text temporarily (hover)
        function highlightScenarioTextTemporary(chartId, dimension) {
            const scenarioIndex = chartId === 'timeline1' ? 0 : 1;
            const textElement = document.querySelectorAll('.scenario-text')[scenarioIndex];
            if (!textElement) return;
            
            const scenario = scenarios[scenarioIndex === 0 ? 'neighborhood' : 'mit'];
            highlightText(textElement, dimension, scenario.keywords, true);
        }
        
        // Highlight text persistently (click)
        function highlightScenarioTextPersistent(scenarioIndex, dimension) {
            const textElement = document.querySelectorAll('.scenario-text')[scenarioIndex];
            if (!textElement) return;
            
            const scenario = scenarios[scenarioIndex === 0 ? 'neighborhood' : 'mit'];
            highlightText(textElement, dimension, scenario.keywords, false);
        }
        
        // Clear temporary highlights
        function clearTemporaryHighlights() {
            document.querySelectorAll('.scenario-text').forEach(el => {
                if (!el.hasAttribute('data-persistent-highlight')) {
                    const originalText = el.getAttribute('data-original-text');
                    if (originalText) {
                        el.innerHTML = originalText;
                    }
                }
            });
        }
        
        // Clear persistent highlights
        function clearPersistentHighlights() {
            document.querySelectorAll('.scenario-text').forEach(el => {
                el.removeAttribute('data-persistent-highlight');
                const originalText = el.getAttribute('data-original-text');
                if (originalText) {
                    el.innerHTML = originalText;
                }
            });
        }
        
        // Clear all highlights
        function clearAllHighlights() {
            // Clear highlight states from all charts
            [timeline1, timeline2].forEach(chart => {
                if (chart) chart.highlightedDimension = null;
            });
            
            // Remove highlight mode from all buttons
            document.querySelectorAll('.toggle-btn').forEach(btn => {
                btn.classList.remove('highlight-mode');
            });
            
            clearPersistentHighlights();
            clearTemporaryHighlights();
        }
        
        // Highlight text helper
        function highlightText(textElement, dimension, keywords, isTemporary) {
            if (!keywords || !keywords[dimension]) return;
            
            const colorMap = {
                logic: { color: '#3b82f6', bgColor: '#dbeafe' },
                emotion: { color: '#ec4899', bgColor: '#fce7f3' },
                balanced: { color: '#10b981', bgColor: '#d1fae5' },
                agenda: { color: '#f59e0b', bgColor: '#fef3c7' }
            };
            
            const colors = colorMap[dimension];
            const keywordList = keywords[dimension];
            
            // Store original text if not already stored
            if (!textElement.hasAttribute('data-original-text')) {
                textElement.setAttribute('data-original-text', textElement.textContent);
            }
            
            const originalText = textElement.getAttribute('data-original-text');
            
            // Sort keywords by length (longer first)
            keywordList.sort((a, b) => b.length - a.length);
            
            // Create regex and highlight
            const regex = new RegExp('(' + keywordList.map(keyword => 
                keyword.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
            ).join('|') + ')', 'gi');
            
            const highlightedText = originalText.replace(regex, match => 
                `<span style="background-color: ${colors.bgColor}; color: ${colors.color}; padding: 1px 3px; border-radius: 3px; font-weight: 600; line-height: 1;">${match}</span>`
            );
            
            // Use requestAnimationFrame to prevent layout competition
            requestAnimationFrame(() => {
                textElement.innerHTML = highlightedText;
                
                if (!isTemporary) {
                    textElement.setAttribute('data-persistent-highlight', dimension);
                }
            });
        }
        
        // Initialize button interactions after page load
        setTimeout(setupButtonInteractions, 100);
        
        // Sound control
        window.soundEnabled = false; // Start with sound off
        function toggleSound() {
            window.soundEnabled = !window.soundEnabled;
            const btn = document.getElementById('sound-toggle');
            btn.textContent = window.soundEnabled ? 'üîä Sound On' : 'üîá Sound Off';
        }
        
        // Game state
        let bearGameState = {
            lastPlayTime: 0,
            cooldownMinutes: 10,
            activeTimer: null,
            timeLeft: 30,
            gameActive: false,
            urgentMode: false
        };
        
        // Handle bear paw icon clicks
        function handleBearPawClick(timelineId) {
            // Check 10-minute cooldown
            const now = Date.now();
            const timeSinceLastPlay = (now - bearGameState.lastPlayTime) / (1000 * 60);
            
            if (timeSinceLastPlay < bearGameState.cooldownMinutes) {
                const remainingMinutes = Math.ceil(bearGameState.cooldownMinutes - timeSinceLastPlay);
                alert(`üêª Bear is resting! Try again in ${remainingMinutes} minute(s).`);
                return;
            }
            
            // Choose random dimension and start game
            startRandomGame(timelineId);
        }
        
        // Start game with random dimension
        function startRandomGame(timelineId) {
            const chart = timelineId === 'timeline1' ? timeline1 : timeline2;
            const chartIndex = timelineId === 'timeline1' ? 1 : 2;
            const dimensions = ['logic', 'emotion', 'balanced', 'agenda'];
            const randomDimension = dimensions[Math.floor(Math.random() * dimensions.length)];
            
            // Set only this dimension visible
            chart.visibleDimensions = {
                logic: false,
                emotion: false,
                balanced: false,
                agenda: false
            };
            chart.visibleDimensions[randomDimension] = true;
            
            // Update button states
            const section = chart.canvas.closest('.timeline-section');
            section.querySelectorAll('.toggle-btn').forEach(btn => {
                btn.classList.remove('active');
                if (btn.dataset.dimension === randomDimension) {
                    btn.classList.add('active');
                }
            });
            
            // Start game
            bearGameState.lastPlayTime = Date.now();
            bearGameState.gameActive = true;
            bearGameState.timeLeft = 20;
            bearGameState.urgentMode = false;
            
            // Disable dimension toggle buttons during game
            const section = chart.canvas.closest('.timeline-section');
            section.querySelectorAll('.toggle-btn').forEach(btn => {
                btn.style.opacity = '0.5';
                btn.style.cursor = 'not-allowed';
                btn.setAttribute('data-game-disabled', 'true');
            });
            
            // Show flyout and start timer
            hideAllFlyouts();
            document.getElementById(`bear-flyout-${chartIndex}`).style.display = 'block';
            startGameTimer();
            chart.redraw();
        }
        
        // Hide all flyouts
        function hideAllFlyouts() {
            document.getElementById('bear-flyout-1').style.display = 'none';
            document.getElementById('bear-flyout-2').style.display = 'none';
        }
        
        // Close mini-game popup
        function closeMiniGame() {
            document.getElementById('mini-game-overlay').style.display = 'none';
        }
        
        // Start game timer
        function startGameTimer() {
            if (bearGameState.activeTimer) return;
            
            bearGameState.activeTimer = setInterval(() => {
                // Don't continue if game is already ending
                if (!bearGameState.gameActive) return;
                
                bearGameState.timeLeft--;
                updateTimerBar();
                
                // Check for victory condition every second
                let victoryAchieved = false;
                [timeline1, timeline2].forEach((chart) => {
                    if (chart.characterData && chart.characterData.position > 0.95) {
                        victoryAchieved = true;
                    }
                });
                
                if (victoryAchieved) {
                    endGame(true);
                    return;
                }
                
                // Start urgent mode at 5 seconds
                if (bearGameState.timeLeft === 5 && !bearGameState.urgentMode) {
                    bearGameState.urgentMode = true;
                    startUrgentMode();
                }
                
                if (bearGameState.timeLeft <= 0) {
                    endGame(false);
                }
            }, 1000);
        }
        
        // Update timer bar
        function updateTimerBar() {
            const percentage = (bearGameState.timeLeft / 20) * 100;
            document.getElementById('bear-timer-fill-1').style.width = percentage + '%';
            document.getElementById('bear-timer-fill-2').style.width = percentage + '%';
        }
        
        // Start urgent flashing mode with DOOM countdown
        function startUrgentMode() {
            document.querySelectorAll('.timeline-section').forEach(section => {
                section.classList.add('urgent');
            });
            
            // Start the DOOM countdown
            startDoomCountdown();
        }
        
        // DOOM-style countdown
        function startDoomCountdown() {
            let countdownNumber = 5;
            let countdownTimer = null;
            
            const showCountdown = () => {
                // Stop if game already ended
                if (!bearGameState.gameActive) {
                    if (countdownTimer) clearTimeout(countdownTimer);
                    const existing = document.getElementById('doom-countdown');
                    if (existing) existing.remove();
                    return;
                }
                
                // Remove any existing countdown
                const existing = document.getElementById('doom-countdown');
                if (existing) existing.remove();
                
                if (countdownNumber <= 0) return;
                
                // Create countdown element
                const countdown = document.createElement('div');
                countdown.id = 'doom-countdown';
                countdown.className = 'doom-countdown';
                countdown.textContent = countdownNumber;
                
                // Make each number bigger and more intense
                const intensity = (6 - countdownNumber) * 0.5;
                countdown.style.fontSize = (8 + intensity * 2) + 'rem';
                countdown.style.filter = `brightness(${1 + intensity})`;
                
                document.body.appendChild(countdown);
                
                // Remove after 800ms
                setTimeout(() => {
                    if (countdown.parentNode) countdown.remove();
                }, 800);
                
                countdownNumber--;
                
                if (countdownNumber >= 0 && bearGameState.gameActive) {
                    countdownTimer = setTimeout(showCountdown, 1000);
                }
            };
            
            showCountdown();
        }
        
        // End game
        function endGame(success) {
            clearInterval(bearGameState.activeTimer);
            bearGameState.activeTimer = null;
            bearGameState.gameActive = false;
            bearGameState.urgentMode = false;
            
            // Stop urgent flashing
            document.querySelectorAll('.timeline-section').forEach(section => {
                section.classList.remove('urgent');
            });
            
            // Re-enable dimension toggle buttons
            document.querySelectorAll('.toggle-btn[data-game-disabled="true"]').forEach(btn => {
                btn.style.opacity = '';
                btn.style.cursor = '';
                btn.removeAttribute('data-game-disabled');
            });
            
            // Remove any countdown overlay
            const countdown = document.getElementById('doom-countdown');
            if (countdown) countdown.remove();
            
            // Show result message
            if (success) {
                // Award 5 RIZ points
                console.log('üéâ Bear made it home! +5 RIZ points awarded!');
                // TODO: Integration with main game RIZ system
                alert('üéâ Runner Bear made it home! +5 RIZ points!');
            } else {
                console.log('üò≠ Bear ran out of time!');
                alert('üò≠ Time\'s up! Bear needs more practice!');
            }
            
            // Animate flyouts closing and reset charts
            setTimeout(() => {
                // Add closing animation class
                const flyouts = document.querySelectorAll('.bear-flyout');
                flyouts.forEach(flyout => {
                    if (flyout.style.display !== 'none') {
                        flyout.style.animation = 'slideIn 0.3s ease-in forwards';
                        setTimeout(() => {
                            flyout.style.display = 'none';
                            flyout.style.animation = ''; // Reset for next time
                        }, 300);
                    }
                });
                
                // Reset all charts to default view (all dimensions visible)
                [timeline1, timeline2].forEach((chart, index) => {
                    // Clear character data
                    if (chart.characterData) {
                        clearInterval(chart.sparkleInterval);
                        chart.sparkleInterval = null;
                        chart.characterData = null;
                    }
                    
                    // Reset all dimensions to visible
                    chart.visibleDimensions = {
                        logic: true,
                        emotion: true,
                        balanced: true,
                        agenda: true
                    };
                    chart.highlightedDimension = null;
                    
                    // Update button states
                    const section = chart.canvas.closest('.timeline-section');
                    section.querySelectorAll('.toggle-btn').forEach(btn => {
                        btn.classList.add('active');
                        btn.classList.remove('highlight-mode');
                    });
                    
                    // Redraw chart
                    chart.redraw();
                });
            }, 500); // Small delay after alert
        }
        
        // Create spark effect
        function createSparkEffect(button) {
            const rect = button.getBoundingClientRect();
            const spark = document.createElement('div');
            spark.className = 'spark-effect';
            spark.style.left = (rect.left + rect.width/2) + 'px';
            spark.style.top = (rect.top + rect.height/2) + 'px';
            document.body.appendChild(spark);
            
            setTimeout(() => spark.remove(), 800);
        }
        
        // Bear mini-game functionality  
        function giveBearPush(timelineId) {
            if (!bearGameState.gameActive) return;
            
            const chartIndex = timelineId === 'timeline1' ? 1 : 2;
            const pushBtn = document.getElementById(`push-btn-${chartIndex}`);
            
            // Create spark effect
            createSparkEffect(pushBtn);
            
            // Find active chart and give boost
            const chart = timelineId === 'timeline1' ? timeline1 : timeline2;
            if (chart.characterData && chart.sparkleInterval) {
                // Give the character a velocity boost
                const boostAmount = 0.006; // Strong boost for game mode
                chart.characterData.pendingBoost = boostAmount;
                
                // Check if bear reached the end (position > 0.95)
                setTimeout(() => {
                    if (bearGameState.gameActive && chart.characterData && chart.characterData.position > 0.95) {
                        endGame(true);
                    }
                }, 100);
            }
        }
    </script>
</body>
</html>