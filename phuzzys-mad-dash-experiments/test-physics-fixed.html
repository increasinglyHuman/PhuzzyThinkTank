<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Physics Test FIXED - Phuzzy's Mad Dash</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f0f0f0;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            text-align: center;
            color: #333;
        }
        .test-controls {
            margin: 20px 0;
            text-align: center;
        }
        button {
            padding: 10px 20px;
            margin: 0 10px;
            font-size: 16px;
            cursor: pointer;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            transition: all 0.3s ease;
        }
        button:hover {
            background: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        .solution-button {
            background: #2196F3;
        }
        .solution-button:hover {
            background: #0b7dda;
        }
        button.active {
            background: #ff5722;
            box-shadow: inset 0 3px 5px rgba(0,0,0,0.3);
            transform: translateY(1px);
        }
        button.active:hover {
            background: #e64a19;
        }
        canvas {
            border: 2px solid #ddd;
            display: block;
            margin: 20px auto;
        }
        .info {
            text-align: center;
            margin: 10px 0;
            font-size: 14px;
            color: #666;
        }
        .physics-info {
            background: #f9f9f9;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-family: monospace;
        }
        .warning {
            color: #ff5722;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Phuzzy's Mad Dash - Physics Testing (FIXED)</h1>
        
        <div class="test-controls" style="display: none;">
            <button id="btn-original" class="physics-btn" onclick="loadSolution('original')">Original Physics</button>
            <button id="btn-solution1" class="physics-btn solution-button active" onclick="loadSolution(1)">Solution 1: Momentum</button>
            <button id="btn-solution2" class="physics-btn solution-button" onclick="loadSolution(2)">Solution 2: Adaptive</button>
            <button id="btn-solution3" class="physics-btn solution-button" onclick="loadSolution(3)">Solution 3: Rail</button>
        </div>
        
        <div class="info" id="current-solution">Current: Solution 1</div>
        
        <div class="race-results" id="race-results" style="display: none;">
            <h3>Race Results</h3>
            <table id="results-table" style="width: 100%; border-collapse: collapse; margin: 10px 0;">
                <thead>
                    <tr style="background: #f0f0f0;">
                        <th style="padding: 8px; text-align: left; border: 1px solid #ddd;">Position</th>
                        <th style="padding: 8px; text-align: left; border: 1px solid #ddd;">Ball</th>
                        <th style="padding: 8px; text-align: left; border: 1px solid #ddd;">Time</th>
                        <th style="padding: 8px; text-align: left; border: 1px solid #ddd;">Clicks</th>
                        <th style="padding: 8px; text-align: left; border: 1px solid #ddd;">Accuracy</th>
                    </tr>
                </thead>
                <tbody id="results-body">
                </tbody>
            </table>
        </div>
        
        <div class="race-stats" id="race-stats" style="display: none; margin: 20px 0; padding: 15px; background: #f9f9f9; border-radius: 5px;">
            <h4>Race Statistics</h4>
            <div id="stats-content" style="font-family: monospace; font-size: 14px;"></div>
        </div>
        
        <div id="canvasContainer" style="width: 800px; height: 400px; overflow: hidden; border: 2px solid #ddd; position: relative; margin: 20px auto;">
            <canvas id="testCanvas" width="16000" height="400" style="position: absolute; top: 0; left: 0;"></canvas>
        </div>
        
        <div class="test-controls">
            <button onclick="startTest()">Start Ball</button>
            <button onclick="stopTest()">Stop</button>
            <!-- <button onclick="toggleDebug()">Toggle Debug</button> -->
            <div style="margin-top: 10px; color: #666;">
                Click near the ball: Left side = push right, Right side = push left
            </div>
        </div>
        
        <div class="physics-info" id="debug-info" style="display: none;">
            <div>Position: <span id="position">0.00</span></div>
            <div>Velocity: <span id="velocity">0.0000</span> <span id="velocity-dir"></span></div>
            <div>Visual Slope: <span id="slope">0.00</span></div>
            <div>State: <span id="state">idle</span></div>
            <div>Gravity Effect: <span id="gravity-effect">0.0000</span></div>
            <div>Camera Offset: <span id="camera-offset">0</span>px</div>
            <div>Ball in Viewport: <span id="ball-viewport">0.0%</span></div>
            <div>Scroll Speed: <span id="scroll-speed">0</span>px/frame</div>
        </div>
    </div>

    <script>
        // Generate multiple tracks with different characteristics
        const tracks = [];
        const dataPoints = 2000; // Points for track generation
        
        // Track configurations
        const trackConfigs = [
            { color: '#2196F3', name: 'blue', main: true },  // Main track (closest)
            { color: '#4CAF50', name: 'green', distance: 1 }, // Mid distance
            { color: '#ec4899', name: 'pink', distance: 2 },  // Far
            { color: '#f59e0b', name: 'ochre', distance: 3 }  // Farthest
        ];
        
        trackConfigs.forEach((config, trackIndex) => {
            const trackData = [];
            
            // Z-depth based ground and peak calculations
            const depthOffset = 5; // Pixels per z-level
            const groundPlane = 10 + (config.distance || 0) * depthOffset; // Ground rises with distance
            const peakHeight = 80 - (config.distance || 0) * depthOffset; // Peak lowers with distance
            
            for (let i = 0; i <= dataPoints; i++) {
                const x = i / dataPoints;
                let y;
                
                // Force start at peak and end at ground
                if (x === 0) {
                    y = peakHeight; // Start at this track's peak
                } else if (x === 1) {
                    y = groundPlane; // End at this track's ground
                } else {
                    // Interpolate between peak and ground with wave patterns
                    const baseProgress = peakHeight + (groundPlane - peakHeight) * x;
                    y = baseProgress;
                    
                    // Apply wave patterns
                    if (config.main) {
                        // Main track waves
                        y += 15 * Math.sin(x * Math.PI * 3) * (1 - x * 0.5);      // Diminish waves toward end
                        y += 20 * Math.sin(x * Math.PI * 24) * (1 - x * 0.7);     // ~24 major hills
                        y += 12 * Math.sin(x * Math.PI * 40) * (1 - x * 0.8);     // ~40 medium features
                        y += 8 * Math.sin(x * Math.PI * 14) * (1 - x * 0.6);      // ~14 large rolling hills
                        y += 5 * Math.sin(x * Math.PI * 60) * (1 - x * 0.9);      // ~60 small bumps
                    } else {
                        // Background track waves - slightly different patterns
                        const waveScale = 1 - (config.distance * 0.1); // Farther tracks have smaller waves
                        y += 10 * Math.sin(x * Math.PI * 2 + trackIndex) * (1 - x * 0.5) * waveScale;
                        y += (15 - trackIndex * 2) * Math.sin(x * Math.PI * (20 + trackIndex * 4)) * (1 - x * 0.7) * waveScale;
                        y += (8 - trackIndex) * Math.sin(x * Math.PI * (36 + trackIndex * 6)) * (1 - x * 0.8) * waveScale;
                        y += 5 * Math.sin(x * Math.PI * (10 + trackIndex * 2)) * (1 - x * 0.9) * waveScale;
                    }
                }
                
                // Soft constraint to avoid flat sections
                let maxHeight = 85;  // Keep 15% margin from top
                const minHeight = 15;  // Keep 15% margin from bottom
                
                // Allow pink and ochre tracks to go higher at start
                if ((trackIndex === 2 || trackIndex === 3) && x < 0.1) {
                    maxHeight = 95; // Allow them to nearly touch the top
                }
                
                // If exceeding bounds, compress the entire wave pattern
                if (y > maxHeight || y < minHeight) {
                    // Calculate how much we're over/under
                    const centerY = 50;
                    const distanceFromCenter = y - centerY;
                    const maxDistance = y > centerY ? (maxHeight - centerY) : (centerY - minHeight);
                    
                    // Compress towards center
                    y = centerY + (distanceFromCenter * maxDistance / Math.abs(distanceFromCenter));
                }
                
                trackData.push({
                    position: x,
                    scores: { test: y }
                });
            }
            
            tracks.push({
                data: trackData,
                config: config
            });
        });
        
        // Main track is the first one for physics
        const testData = tracks[0].data;
        
        let canvas = document.getElementById('testCanvas');
        let ctx = canvas.getContext('2d');
        let canvasContainer = document.getElementById('canvasContainer');
        let animationId = null;
        let ballPosition = 0;
        let ballVelocity = 0;
        let lastSlope = 0;
        let debugMode = false;
        let currentSolution = 'solution1'; // Default to momentum physics
        let cameraOffset = 0; // Track how far we've scrolled the canvas
        let cameraTargetOffset = 0; // Where the camera wants to be
        let radarAngle = 0; // Radar sweep angle
        let radarTrails = []; // Store radar trail positions
        
        // Track balls for each track - all start at same position with momentum physics
        let trackBalls = [
            { position: 0.01, velocity: 0, lastSlope: 0, clickCount: 0, goodClicks: 0, missClicks: 0, pushRightClicks: 0, pushLeftClicks: 0, finished: false },  // Blue (main)
            { position: 0.01, velocity: 0, lastSlope: 0, clickCount: 0, goodClicks: 0, missClicks: 0, pushRightClicks: 0, pushLeftClicks: 0, finished: false }, // Green
            { position: 0.01, velocity: 0, lastSlope: 0, clickCount: 0, goodClicks: 0, missClicks: 0, pushRightClicks: 0, pushLeftClicks: 0, finished: false }, // Pink
            { position: 0.01, velocity: 0, lastSlope: 0, clickCount: 0, goodClicks: 0, missClicks: 0, pushRightClicks: 0, pushLeftClicks: 0, finished: false }  // Yellow
        ];
        
        // Race state
        let raceStarted = false;
        let countdownTimer = 0;
        let countdownNumber = 3;
        
        // Race timing and finish tracking
        let raceStartTime = null;
        let finishResults = [];
        const ballNames = ['Phuzzy', 'Bumble', 'Honey', 'Grizzly'];
        const ballColors = ['#2196F3', '#4CAF50', '#ec4899', '#f59e0b'];
        
        // User click tracking for AI simulation
        let userClickCount = 0;
        let userGoodClicks = 0;
        let userMissClicks = 0;
        let userPushRightClicks = 0;
        let userPushLeftClicks = 0;
        let userClickAccuracy = 0.7; // Default 70% accuracy
        
        // Physics configurations for each solution
        const physicsConfigs = {
            original: {
                gravity: 0.0003,
                friction: 0.99,  // Less friction for more natural movement
                pushForce: 0.001,  // Increased push force for better feedback
                applyPhysics: originalPhysics
            },
            solution1: {
                gravity: 0.0003,
                friction: 0.985,  // More friction to slow down
                pushForce: 0.001,  // Increased push force for better feedback
                momentumConservation: 0.7,  // Much less momentum preservation
                applyPhysics: solution1Physics
            },
            solution2: {
                baseGravity: 0.0003,
                friction: 0.99,
                pushForce: 0.001,  // Increased push force for better feedback
                applyPhysics: solution2Physics
            },
            solution3: {
                gravity: 0.0003,
                friction: 0.99,
                pushForce: 0.001,  // Increased push force for better feedback
                railAdhesion: 0.95,
                applyPhysics: solution3Physics
            }
        };
        
        function originalPhysics(velocity, visualSlope, steepness, config) {
            // Apply gravity based on visual slope
            // Positive visualSlope = uphill, negative = downhill
            velocity -= config.gravity * visualSlope * 0.1;  // Gravity opposes uphill, assists downhill
            
            return velocity;
        }
        
        function solution1Physics(velocity, visualSlope, steepness, config) {
            const isPeak = lastSlope < 0 && visualSlope > 0;  // Was going down, now going up
            const isValley = lastSlope > 0 && visualSlope < 0;  // Was going up, now going down
            
            // Apply gravity
            velocity -= config.gravity * visualSlope * 0.1;
            
            // Momentum conservation at transitions
            if (isValley || isPeak) {
                velocity *= config.momentumConservation;
            }
            
            return velocity;
        }
        
        function solution2Physics(velocity, visualSlope, steepness, config) {
            const curveSharpness = Math.abs(visualSlope - lastSlope) / 100;
            const adaptiveGravityMultiplier = Math.max(0.3, 1 - curveSharpness * 0.7);
            const gravity = config.baseGravity * adaptiveGravityMultiplier;
            
            // Apply adaptive gravity
            velocity -= gravity * visualSlope * 0.1;
            
            // Help at sharp curves
            if (curveSharpness > 0.1) {
                velocity += config.pushForce * 0.001 * curveSharpness;
            }
            
            return velocity;
        }
        
        function solution3Physics(velocity, visualSlope, steepness, config) {
            // Convert visual slope to angle
            const slopeAngle = Math.atan2(visualSlope, 100);
            const gravityComponent = config.gravity * Math.sin(slopeAngle);
            
            // Apply gravity along the rail
            velocity -= gravityComponent * 3;  // Stronger effect for rail physics
            
            // Prevent stalling on steep slopes
            if (Math.abs(velocity) < 0.0005 && Math.abs(visualSlope) > 20) {
                velocity = -Math.sign(visualSlope) * 0.001;  // Roll down the slope
            }
            
            return velocity;
        }
        
        function drawBackgroundGrid() {
            ctx.save();
            
            // Apply parallax offset (25% of camera movement for far background)
            const parallaxOffset = cameraOffset * 0.25;
            const gridSpacing = 50; // 50px grid squares
            
            // Light grey lines
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            
            // Calculate starting position to ensure continuous grid
            const startX = -(parallaxOffset % gridSpacing);
            
            // Vertical lines
            for (let x = startX; x < canvas.width; x += gridSpacing) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let y = 0; y < canvas.height; y += gridSpacing) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Add subtle axis lines in slightly darker grey
            ctx.strokeStyle = '#d0d0d0';
            ctx.lineWidth = 2;
            
            // Main horizontal axis (middle of canvas)
            ctx.beginPath();
            ctx.moveTo(0, canvas.height / 2);
            ctx.lineTo(canvas.width, canvas.height / 2);
            ctx.stroke();
            
            ctx.restore();
        }
        
        function updateCamera() {
            // Calculate where we want the camera to position the ball
            const ballScreenX = ballPosition * canvas.width;
            const containerWidth = canvasContainer.offsetWidth; // 800px
            
            // Target: keep ball at 1/3 from left so player can click both sides
            cameraTargetOffset = ballScreenX - containerWidth / 3;
            
            // Clamp target to valid range
            const maxScroll = canvas.width - containerWidth;
            cameraTargetOffset = Math.max(0, Math.min(maxScroll, cameraTargetOffset));
            
            // Calculate distance to target
            const distance = Math.abs(cameraTargetOffset - cameraOffset);
            
            // Easing function: slow start, speed up, slow down near target
            let easeSpeed;
            if (distance < 5) {
                // Very close - crawl to avoid jitter
                easeSpeed = 0.05;
            } else if (distance < 20) {
                // Close - slow down
                easeSpeed = 0.1;
            } else if (distance < 100) {
                // Medium distance - moderate speed
                easeSpeed = 0.15;
            } else {
                // Far away - speed up
                easeSpeed = 0.2;
            }
            
            // Lerp (linear interpolation) with easing
            cameraOffset += (cameraTargetOffset - cameraOffset) * easeSpeed;
            
            // Store actual camera movement for debug
            window.currentScrollSpeed = (cameraTargetOffset - cameraOffset) * easeSpeed;
            
            // Apply the scroll offset to the canvas
            canvas.style.transform = `translateX(-${cameraOffset}px)`;
        }
        
        
        function drawRadar() {
            // Fixed position half off the left side of screen
            const radarX = -80; // Half off screen (radius is 160)
            const radarY = 200;
            const radarRadius = 160; // Doubled size
            
            ctx.save();
            
            // Radar background circle - transparent
            // Remove the black fill - just draw the grid and sweep
            
            // Radar grid lines - pale grey
            ctx.strokeStyle = 'rgba(200, 200, 200, 0.3)';
            ctx.lineWidth = 1;
            
            // Concentric circles
            for (let i = 1; i <= 3; i++) {
                ctx.beginPath();
                ctx.arc(radarX, radarY, radarRadius * i / 3, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Cross lines
            ctx.beginPath();
            ctx.moveTo(radarX - radarRadius, radarY);
            ctx.lineTo(radarX + radarRadius, radarY);
            ctx.moveTo(radarX, radarY - radarRadius);
            ctx.lineTo(radarX, radarY + radarRadius);
            ctx.stroke();
            
            // Radar sweep
            const sweepLength = radarRadius;
            const sweepX = radarX + Math.cos(radarAngle) * sweepLength;
            const sweepY = radarY + Math.sin(radarAngle) * sweepLength;
            
            // Create gradient for sweep line
            const gradient = ctx.createLinearGradient(radarX, radarY, sweepX, sweepY);
            gradient.addColorStop(0, 'rgba(0, 255, 0, 0.1)');
            gradient.addColorStop(0.7, 'rgba(0, 255, 0, 0.8)');
            gradient.addColorStop(1, 'rgba(0, 255, 0, 1)');
            
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(radarX, radarY);
            ctx.lineTo(sweepX, sweepY);
            ctx.stroke();
            
            // Draw sweep cone (fading trail) - bolder shadow
            ctx.fillStyle = 'rgba(0, 255, 0, 0.25)'; // Increased opacity for bolder shadow
            ctx.beginPath();
            ctx.moveTo(radarX, radarY);
            ctx.arc(radarX, radarY, radarRadius, radarAngle - 0.8, radarAngle, false); // Wider trail
            ctx.closePath();
            ctx.fill();
            
            // Add blips on radar
            const blipPositions = [
                { angle: Math.PI * 0.3, dist: 0.6, size: 4 },
                { angle: Math.PI * 0.8, dist: 0.8, size: 3 },
                { angle: Math.PI * 1.5, dist: 0.4, size: 5 },
                { angle: Math.PI * 1.2, dist: 0.9, size: 3 }
            ];
            
            blipPositions.forEach(blip => {
                // Calculate fade based on sweep position
                let angleDiff = Math.abs(radarAngle - blip.angle);
                if (angleDiff > Math.PI) angleDiff = 2 * Math.PI - angleDiff;
                const fade = Math.max(0, 1 - angleDiff / Math.PI);
                
                const blipX = radarX + Math.cos(blip.angle) * radarRadius * blip.dist;
                const blipY = radarY + Math.sin(blip.angle) * radarRadius * blip.dist;
                
                ctx.fillStyle = `rgba(0, 255, 0, ${0.5 + fade * 0.5})`;
                ctx.beginPath();
                ctx.arc(blipX, blipY, blip.size, 0, Math.PI * 2);
                ctx.fill();
            });
            
            // Radar border - pale grey to match
            ctx.strokeStyle = 'rgba(200, 200, 200, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(radarX, radarY, radarRadius, 0, Math.PI * 2);
            ctx.stroke();
            
            // Center dot
            ctx.fillStyle = 'rgba(0, 255, 0, 1)';
            ctx.beginPath();
            ctx.arc(radarX, radarY, 3, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
            
            // Update radar angle
            radarAngle += 0.02; // Sweep speed
            if (radarAngle > Math.PI * 2) {
                radarAngle -= Math.PI * 2;
            }
        }
        
        function drawScene() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw parallax background grid
            drawBackgroundGrid();
            
            // Draw radar at fixed position on the track
            drawRadar();
            
            // Draw all tracks with parallax (back to front)
            tracks.slice().reverse().forEach((track, reverseIndex) => {
                const trackIndex = tracks.length - 1 - reverseIndex;
                // Much gentler parallax - from 1.0 to 0.85
                const parallaxFactor = track.config.main ? 1 : 0.95 - (track.config.distance * 0.05);
                
                ctx.save();
                ctx.translate(-cameraOffset * (1 - parallaxFactor), 0);
                
                // Fainter lines for distant tracks
                ctx.globalAlpha = track.config.main ? 1 : 0.8 - (track.config.distance * 0.1);
                ctx.strokeStyle = track.config.color;
                ctx.lineWidth = track.config.main ? 6 : 4; // Keep blue at 6px, double others to 4px
                
                ctx.beginPath();
                for (let i = 0; i < track.data.length; i++) {
                    // No length compensation - all tracks same logical length
                    const x = track.data[i].position * canvas.width;
                    const y = canvas.height - (track.data[i].scores.test / 100 * canvas.height);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                
                // Don't draw random balls anymore - we'll draw them separately
                
                ctx.restore();
            });
            
            // Draw balls on all tracks (back to front for proper z-order)
            // First draw the farthest balls (ochre, pink, green), then blue on top
            console.log('Starting ball drawing, trackBalls:', trackBalls.length);
            // Draw in proper z-order: farthest to nearest
            for (let i = tracks.length - 1; i >= 0; i--) {
                const track = tracks[i];
                const trackIndex = i;
                const ball = trackBalls[trackIndex];
                console.log(`Track ${i}: ${track.config.name}, ball exists: ${!!ball}`);
                if (!ball) continue;
                
                // Skip main track ball physics here (handled separately)
                if (trackIndex === 0) {
                    ball.position = ballPosition;
                } else {
                    // All balls use momentum physics
                    // Use raw position for physics calculations
                    const dataIndex = Math.max(0, Math.min(track.data.length - 2, Math.floor(ball.position * (track.data.length - 1))));
                    const nextIndex = dataIndex + 1;
                    const currentY = track.data[dataIndex].scores.test;
                    const nextY = track.data[nextIndex].scores.test;
                    
                    // Calculate visual slope
                    const visualSlope = nextY - currentY;
                    
                    // Momentum physics with AI adjustments
                    const config = physicsConfigs.solution1; // Use momentum physics
                    const isPeak = ball.lastSlope < 0 && visualSlope > 0;
                    const isValley = ball.lastSlope > 0 && visualSlope < 0;
                    
                    // Apply gravity
                    ball.velocity -= config.gravity * visualSlope * 0.1;
                    
                    // Momentum conservation at transitions
                    if (isValley || isPeak) {
                        ball.velocity *= config.momentumConservation;
                    }
                    
                    // AI uses only simulated clicks - no rubber band mechanics
                    
                    if (raceStarted) {
                        // Initialize AI click tracking if needed
                        if (!ball.lastClickTime) {
                            ball.lastClickTime = Date.now();
                        }
                        
                        // AI has independent clicking
                        const timeSinceLastClick = Date.now() - ball.lastClickTime;
                        
                        // Each AI has their own persistent click rate and interval
                        if (!ball.clickRate) {
                            ball.clickRate = 0.6 + Math.random() * 0.8; // 0.6x to 1.4x speed variation
                            ball.baseInterval = 200 + Math.random() * 200; // 200-400ms base interval
                        }
                        const aiClickDelay = ball.baseInterval * ball.clickRate;
                        
                        // AI always tries to click at their own rate
                        if (timeSinceLastClick > aiClickDelay) {
                            ball.clickCount++;
                            ball.lastClickTime = Date.now();
                            
                            // Each AI has their own persistent accuracy
                            if (!ball.baseAccuracy) {
                                ball.baseAccuracy = 0.6 + Math.random() * 0.3; // 60-90% base accuracy
                            }
                            
                            // Debug first few clicks
                            if (ball.clickCount <= 3) {
                                console.log(`${ballNames[trackIndex]} clicked! Rate: ${ball.clickRate.toFixed(2)}, Accuracy: ${ball.baseAccuracy.toFixed(2)}`);
                            }
                            const aiAccuracy = ball.baseAccuracy - (track.config.distance * 0.05);
                            const clickRoll = Math.random();
                            
                            if (clickRoll < aiAccuracy * 0.8) {
                                // Good click - push forward (80% of good clicks)
                                ball.velocity += config.pushForce;
                                ball.goodClicks++;
                                ball.pushRightClicks++;
                                // Show click effect for AI
                                showAIClickFeedback(ball, track, 'push-right');
                            } else if (clickRoll < aiAccuracy) {
                                // Wrong side click - push backward (20% of good clicks)
                                ball.velocity -= config.pushForce;  // Full backward force like player
                                ball.goodClicks++;
                                ball.pushLeftClicks++;
                                showAIClickFeedback(ball, track, 'push-left');
                            } else {
                                // Miss
                                ball.missClicks++;
                                showAIClickFeedback(ball, track, 'miss');
                            }
                        }
                        
                        // No rubber band mechanics - pure skill based
                        
                        // Extra damping to prevent runaway speeds
                        if (Math.abs(ball.velocity) > 0.002) {
                            ball.velocity *= 0.95; // Additional slowdown at high speeds
                        }
                    } else {
                        // Before race starts, no movement
                        ball.velocity *= 0.9; // Heavy damping
                    }
                    
                    // Apply friction
                    ball.velocity *= config.friction;
                    
                    // Store slope for next frame
                    ball.lastSlope = visualSlope;
                    
                    // Update position
                    ball.position += ball.velocity;
                    
                    // Debug extreme positions
                    if (ball.position > 0.99 && !ball.debugged) {
                        console.log(`${ballNames[trackIndex]} approaching finish at ${(ball.position * 100).toFixed(1)}%`);
                        ball.debugged = true;
                    }
                    
                    // Global speed limit for background balls
                    if (Math.abs(ball.velocity) > 0.0015) {
                        ball.velocity = Math.sign(ball.velocity) * 0.0015;
                    }
                    
                    // During countdown, keep balls in starting box
                    if (!raceStarted) {
                        if (ball.position > 0.005) {
                            ball.position = 0.005;
                            ball.velocity *= 0.2; // Dampen velocity heavily
                        } else if (ball.position < 0.0005) {
                            // Invisible barrier behind to prevent rolling backward
                            ball.position = 0.0005;
                            ball.velocity = Math.abs(ball.velocity) * 0.3; // Bounce forward slightly
                        }
                    }
                    
                    // Check for finish BEFORE clamping
                    if (ball.position >= 0.995 && !ball.finished) {
                        // Mark as finished
                        ball.finished = true;
                        
                        // Record finish if not already recorded
                        if (!finishResults.find(r => r.ballIndex === trackIndex)) {
                            const finishTime = (Date.now() - raceStartTime) / 1000;
                            const accuracy = ball.clickCount > 0 ? ball.goodClicks / ball.clickCount : 0;
                            console.log(`${ballNames[trackIndex]} finished in ${finishTime.toFixed(2)}s`);
                            finishResults.push({
                                ballIndex: trackIndex,
                                name: ballNames[trackIndex],
                                color: ballColors[trackIndex],
                                time: finishTime,
                                clicks: ball.clickCount,
                                accuracy: accuracy
                            });
                            updateRaceResults();
                        }
                    }
                    
                    // Clamp position to valid range
                    if (ball.position > 0.995) {
                        ball.position = 0.995; // Stop at end
                        if (ball.finished) {
                            ball.velocity = 0; // Only stop if finished
                        }
                    } else if (ball.position < 0) {
                        ball.position = 0;
                        ball.velocity = Math.abs(ball.velocity) * 0.5;
                    }
                }
                
                // Get current position on track curve
                const parallaxFactor = track.config.main ? 1 : 0.95 - (track.config.distance * 0.05);
                
                // For finding the Y position, we need to look up the correct spot on the track data
                // Ball position is normalized 0-1, but we need to account for track stretching
                const dataLookupPosition = ball.position;  // Use raw position for data lookup
                const dataIndex = Math.max(0, Math.min(track.data.length - 2, Math.floor(dataLookupPosition * (track.data.length - 1))));
                const nextIndex = dataIndex + 1;
                const localProgress = (dataLookupPosition * (track.data.length - 1)) % 1;
                
                const currentY = track.data[dataIndex].scores.test;
                const nextY = track.data[nextIndex].scores.test;
                const interpolatedY = currentY + (nextY - currentY) * localProgress;
                
                // For X position - no length compensation, all tracks same length
                const ballX = ball.position * canvas.width;
                const adjustedX = ballX - cameraOffset * (1 - parallaxFactor);
                const ballY = canvas.height - (interpolatedY / 100 * canvas.height);
                
                // Debug first frame
                if (!ball.debuggedDraw) {
                    console.log(`Drawing ${ballNames[trackIndex]}: pos=${ball.position}, ballX=${ballX}, adjustedX=${adjustedX}, ballY=${ballY}, visible=${adjustedX >= -ballRadius - 100 && adjustedX <= canvas.width + ballRadius + 100}`);
                    ball.debuggedDraw = true;
                }
                
                // Ball sizes decrease with distance (less dramatic for better perception)
                let ballRadius;
                if (track.config.main) {
                    ballRadius = 15; // Main ball
                } else {
                    ballRadius = 15 - track.config.distance * 1; // 14, 13, 12 for background tracks
                }
                
                // Only draw if ball is in viewport (with generous margin)
                const viewportWidth = 800; // The actual viewport width
                console.log(`Ball ${trackIndex} viewport check: adjustedX=${adjustedX}, viewportWidth=${viewportWidth}, inView=${adjustedX >= -ballRadius - 100 && adjustedX <= viewportWidth + ballRadius + 100}`);
                if (adjustedX >= -ballRadius - 100 && adjustedX <= viewportWidth + ballRadius + 100) {
                    // Add slight shadow for depth on background tracks
                    if (!track.config.main) {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                        ctx.beginPath();
                        ctx.arc(adjustedX + 2, ballY - ballRadius + 2, ballRadius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                    
                    // Draw ball with better visibility
                    ctx.save();
                    
                    // DEBUG: Draw a simple rectangle first
                    ctx.fillStyle = 'red';
                    ctx.fillRect(adjustedX - 5, ballY - 25, 10, 10);
                    
                    if (!track.config.main) {
                        // Make background balls more visible
                        ctx.globalAlpha = 0.9 - (track.config.distance * 0.05); // Less transparency
                    }
                    ctx.fillStyle = track.config.color;
                    ctx.beginPath();
                    ctx.arc(adjustedX, ballY - ballRadius, ballRadius, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                    
                    // Visual effects based on absolute speed
                    const absSpeed = Math.abs(ball.velocity);
                    
                    // Show speed lines when going fast
                    if (absSpeed > 0.0015) {
                        ctx.save();
                        ctx.strokeStyle = track.config.color;
                        ctx.lineWidth = 2;
                        ctx.globalAlpha = Math.min(0.6, (absSpeed - 0.0015) * 500);
                        
                        const numLines = Math.floor(absSpeed * 2000);
                        for (let i = 0; i < numLines; i++) {
                            const lineX = adjustedX - (i + 1) * 12;
                            const lineY = ballY - ballRadius + (Math.random() - 0.5) * 8;
                            ctx.beginPath();
                            ctx.moveTo(lineX, lineY);
                            ctx.lineTo(lineX - 8, lineY);
                            ctx.stroke();
                        }
                        ctx.restore();
                    }
                    
                    // Removed water drop effects - they looked funny
                    
                    // Add highlight for depth
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.beginPath();
                    ctx.arc(adjustedX - ballRadius/3, ballY - ballRadius - ballRadius/3, ballRadius/3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Debug: Show actual position above each ball
                    if (debugMode || true) { // Always show for now
                        ctx.fillStyle = track.config.color;
                        ctx.font = 'bold 10px Arial';
                        ctx.fillText(`${(ball.position * 100).toFixed(0)}%`, adjustedX - 10, ballY - ballRadius - 20);
                    }
                }
            }
            
            // Draw direction indicator (these scroll with the world)
            ctx.fillStyle = '#666';
            ctx.font = '14px Arial';
            ctx.fillText('← Peak', 10, 30);
            ctx.fillText('Ground →', canvas.width - 70, 30);
            
            // Draw progress markers on each track with proper parallax
            const markerPositions = [0.25, 0.5, 0.75, 0.995];
            const markerLabels = ['25%', '50%', '75%', 'FIN'];
            
            tracks.forEach((track, trackIndex) => {
                const parallaxFactor = track.config.main ? 1 : 0.95 - (track.config.distance * 0.05);
                
                ctx.save();
                ctx.translate(-cameraOffset * (1 - parallaxFactor), 0);
                
                // Get track Y position at 50% for label placement
                const midIndex = Math.floor(track.data.length / 2);
                const midY = canvas.height - (track.data[midIndex].scores.test / 100 * canvas.height);
                
                markerPositions.forEach((pos, i) => {
                    const x = pos * canvas.width;
                    
                    // Draw vertical line
                    ctx.strokeStyle = track.config.color;
                    ctx.lineWidth = 1;
                    ctx.setLineDash([5, 5]);
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                    ctx.stroke();
                    ctx.setLineDash([]);
                    
                    // Draw label
                    ctx.fillStyle = track.config.color;
                    ctx.font = '10px Arial';
                    ctx.fillText(markerLabels[i], x + 2, midY + trackIndex * 15);
                });
                
                ctx.restore();
            });
            
            // Draw version number in top right
            ctx.fillStyle = '#999';
            ctx.font = '12px Arial';
            ctx.fillText('v2.0.6-debug', canvas.width - 50, 20);
            
            // Update race stats in real-time
            if (raceStarted && raceStartTime) {
                updateRaceStats();
            }
            
            // Ensure ball position stays in bounds
            ballPosition = Math.max(0, Math.min(1, ballPosition));
            
            // Update main ball position in trackBalls array
            trackBalls[0].position = ballPosition;
            
            // Draw countdown if active - position it in viewport
            if (!raceStarted && countdownTimer > 0) {
                ctx.save();
                ctx.font = 'bold 120px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // Position countdown in center of viewport accounting for camera offset
                const viewportCenterX = cameraOffset + 400; // Center of 800px viewport
                const viewportCenterY = 200;
                
                // Shadow for visibility
                ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                ctx.fillText(countdownNumber || 'GO!', viewportCenterX + 2, viewportCenterY + 2);
                
                // Main text
                if (countdownNumber > 0) {
                    ctx.fillStyle = '#FF5722';
                    ctx.fillText(countdownNumber, viewportCenterX, viewportCenterY);
                } else {
                    ctx.fillStyle = '#4CAF50';
                    ctx.fillText('GO!', viewportCenterX, viewportCenterY);
                }
                ctx.restore();
            }
            
            // Update debug info
            if (debugMode) {
                // Get data for debug display
                const dataIndex = Math.floor(ballPosition * (testData.length - 1));
                const nextIndex = Math.min(dataIndex + 1, testData.length - 1);
                const currentY = testData[dataIndex].scores.test;
                const nextY = testData[nextIndex].scores.test;
                const visualSlope = nextY - currentY;
                
                document.getElementById('position').textContent = ballPosition.toFixed(3);
                document.getElementById('velocity').textContent = Math.abs(ballVelocity).toFixed(4);
                document.getElementById('velocity-dir').textContent = ballVelocity > 0 ? '→' : ballVelocity < 0 ? '←' : '•';
                document.getElementById('slope').textContent = visualSlope.toFixed(2);
                
                const state = visualSlope > 0 ? 'uphill' : visualSlope < 0 ? 'downhill' : 'flat';
                document.getElementById('state').textContent = state;
                
                // Show gravity effect
                const gravityEffect = -visualSlope * 0.0003 * 0.1;
                document.getElementById('gravity-effect').textContent = gravityEffect.toFixed(6);
                
                // Show camera info
                document.getElementById('camera-offset').textContent = Math.round(cameraOffset);
                const ballRelativeX = (ballPosition * canvas.width) - cameraOffset;
                const ballPercentage = (ballRelativeX / canvasContainer.offsetWidth) * 100;
                document.getElementById('ball-viewport').textContent = ballPercentage.toFixed(1) + '%';
                document.getElementById('scroll-speed').textContent = (window.currentScrollSpeed || 0).toFixed(2);
            }
        }
        
        function animate() {
            const config = physicsConfigs[currentSolution];
            
            // Get slope
            const dataIndex = Math.floor(ballPosition * (testData.length - 1));
            const nextIndex = Math.min(dataIndex + 1, testData.length - 1);
            const currentY = testData[dataIndex].scores.test;
            const nextY = testData[nextIndex].scores.test;
            
            // Visual slope: positive = uphill, negative = downhill
            // Since higher Y values are at the top of the screen visually, we don't invert
            const visualSlope = nextY - currentY;  // Positive when going up visually
            const steepness = Math.abs(visualSlope) / 100;
            
            // Only apply physics if race has started
            if (raceStarted) {
                // Apply physics
                ballVelocity = config.applyPhysics(ballVelocity, visualSlope, steepness, config);
                
                // Apply friction (always opposes motion)
                ballVelocity *= config.friction;
                
                // Apply velocity cap (rate limiter)
                const maxVelocity = 0.002; // Further reduced max speed
                ballVelocity = Math.max(-maxVelocity, Math.min(maxVelocity, ballVelocity));
                
                // Update position
                ballPosition += ballVelocity;
            } else {
                // During countdown, keep ball in starting box
                if (ballPosition > 0.005) {
                    ballPosition = 0.005;
                    ballVelocity *= 0.2; // Heavy damping
                } else if (ballPosition < 0.0005) {
                    // Invisible barrier behind to prevent rolling backward
                    ballPosition = 0.0005;
                    ballVelocity = Math.abs(ballVelocity) * 0.3; // Bounce forward slightly
                }
            }
            
            // Update countdown
            if (!raceStarted && countdownTimer > 0) {
                countdownTimer--;
                if (countdownTimer % 60 === 0) { // Every second (60 frames)
                    countdownNumber--;
                    if (countdownNumber === 0) {
                        // Show GO! for this frame
                    } else if (countdownNumber < 0) {
                        raceStarted = true;
                        raceStartTime = Date.now(); // Start the timer
                    }
                }
            }
            
            // Bounce at boundaries
            if (ballPosition < 0) {
                ballPosition = 0;
                ballVelocity = Math.abs(ballVelocity) * 0.5;  // Bounce with energy loss
            } else if (ballPosition > 0.995 && raceStarted) {
                // Player finished!
                ballPosition = 0.995; // Keep at edge
                ballVelocity = 0;
                
                // Record finish if not already recorded
                if (!finishResults.find(r => r.ballIndex === 0)) {
                    const finishTime = (Date.now() - raceStartTime) / 1000;
                    finishResults.push({
                        ballIndex: 0,
                        name: ballNames[0],
                        color: ballColors[0],
                        time: finishTime,
                        clicks: userClickCount,
                        accuracy: userClickAccuracy
                    });
                    updateRaceResults();
                }
            }
            
            // SCROLLING LOGIC: Update camera based on ball position
            updateCamera();
            
            lastSlope = visualSlope;
            
            drawScene();
            animationId = requestAnimationFrame(animate);
        }
        
        function startTest() {
            if (!animationId) {
                // Reset race state
                raceStarted = false;
                countdownTimer = 240; // 4 seconds total (3-2-1-GO)
                countdownNumber = 3;
                finishResults = []; // Clear previous results
                document.getElementById('race-results').style.display = 'none';
                
                // Reset click tracking
                userClickCount = 0;
                userGoodClicks = 0;
                userMissClicks = 0;
                userPushRightClicks = 0;
                userPushLeftClicks = 0;
                userClickAccuracy = 0.7;
                
                // Reset all balls to start position at peak
                ballPosition = 0.01;
                ballVelocity = 0;
                trackBalls.forEach(ball => {
                    ball.position = 0.01;  // All start slightly from left
                    ball.velocity = 0;
                    ball.lastSlope = 0;
                    ball.clickCount = 0;
                    ball.goodClicks = 0;
                    ball.missClicks = 0;
                    ball.pushRightClicks = 0;
                    ball.pushLeftClicks = 0;
                    ball.lastClickTime = null;
                    ball.finished = false;
                    ball.debugged = false;
                });
                
                // Now start the animation which will show balls and countdown
                animate();
            }
        }
        
        function stopTest() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
                document.getElementById('race-stats').style.display = 'none';
            }
        }
        
        function pushBall() {
            const config = physicsConfigs[currentSolution];
            ballVelocity += config.pushForce;  // Push forward (right)
        }
        
        function pushBallBackward() {
            const config = physicsConfigs[currentSolution];
            ballVelocity -= config.pushForce;  // Push backward (left)
        }
        
        function toggleDebug() {
            debugMode = !debugMode;
            document.getElementById('debug-info').style.display = debugMode ? 'block' : 'none';
        }
        
        function loadSolution(solution) {
            stopTest();
            
            // Remove active class from all buttons
            document.querySelectorAll('.physics-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Add active class to selected button and update current solution
            if (solution === 'original') {
                currentSolution = 'original';
                document.getElementById('current-solution').textContent = 'Current: Original Physics';
                document.getElementById('btn-original').classList.add('active');
            } else {
                currentSolution = 'solution' + solution;
                document.getElementById('current-solution').textContent = 'Current: Solution ' + solution;
                document.getElementById('btn-solution' + solution).classList.add('active');
            }
            
            ballPosition = 0.02;  // Start near left edge (2%)
            ballVelocity = 0;
            cameraOffset = 0;  // Reset camera
            cameraTargetOffset = 0;  // Reset camera target
            canvas.style.transform = 'translateX(0px)';  // Reset visual position
            drawScene();
        }
        
        // Function to draw empty scene (no balls, no countdown)
        function drawEmptyScene() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw parallax background grid
            drawBackgroundGrid();
            
            // Draw radar at fixed position on the track
            drawRadar();
            
            // Draw all tracks with parallax (back to front) but NO BALLS
            tracks.slice().reverse().forEach((track, reverseIndex) => {
                const trackIndex = tracks.length - 1 - reverseIndex;
                const parallaxFactor = track.config.main ? 1 : 0.95 - (track.config.distance * 0.05);
                
                ctx.save();
                ctx.translate(-cameraOffset * (1 - parallaxFactor), 0);
                
                // Fainter lines for distant tracks
                ctx.globalAlpha = track.config.main ? 1 : 0.8 - (track.config.distance * 0.1);
                ctx.strokeStyle = track.config.color;
                ctx.lineWidth = track.config.main ? 6 : 4;
                
                ctx.beginPath();
                for (let i = 0; i < track.data.length; i++) {
                    // No length compensation - all tracks same logical length
                    const x = track.data[i].position * canvas.width;
                    const y = canvas.height - (track.data[i].scores.test / 100 * canvas.height);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
                ctx.restore();
            });
            
            // Draw direction indicator (these scroll with the world)
            ctx.fillStyle = '#666';
            ctx.font = '14px Arial';
            ctx.fillText('← Peak', 10, 30);
            ctx.fillText('Ground →', canvas.width - 70, 30);
        }
        
        // Click handling for push mechanic
        canvasContainer.addEventListener('click', function(e) {
            if (!animationId || !raceStarted) return;
            
            // Get click position relative to canvas
            const rect = canvasContainer.getBoundingClientRect();
            const clickX = e.clientX - rect.left + cameraOffset;
            const clickY = e.clientY - rect.top;
            
            // Get ball screen position
            const ballScreenX = ballPosition * canvas.width;
            const dataIndex = Math.floor(ballPosition * (testData.length - 1));
            const ballScreenY = canvas.height - (testData[dataIndex].scores.test / 100 * canvas.height) - 15;
            
            // Calculate distance from click to ball
            const distance = Math.sqrt(Math.pow(clickX - ballScreenX, 2) + Math.pow(clickY - ballScreenY, 2));
            
            // Max click distance (50 pixels)
            const maxDistance = 50;
            
            // Track user clicks
            userClickCount++;
            trackBalls[0].lastClickTime = Date.now();
            
            if (distance <= maxDistance) {
                const config = physicsConfigs[currentSolution];
                
                // Determine which side of ball was clicked
                if (clickX < ballScreenX) {
                    // Clicked left of ball - push forward
                    ballVelocity += config.pushForce;
                    showClickFeedback(e.clientX - rect.left, e.clientY - rect.top, 'push-right');
                    userGoodClicks++;
                    userPushRightClicks++;
                } else {
                    // Clicked right of ball - push backward
                    ballVelocity -= config.pushForce;
                    showClickFeedback(e.clientX - rect.left, e.clientY - rect.top, 'push-left');
                    userGoodClicks++;
                    userPushLeftClicks++;
                }
            } else {
                // Too far away
                showClickFeedback(e.clientX - rect.left, e.clientY - rect.top, 'miss');
                userMissClicks++;
            }
            
            // Update user accuracy
            userClickAccuracy = userGoodClicks / userClickCount;
        });
        
        // Visual feedback for AI clicks
        function showAIClickFeedback(ball, track, type) {
            // Calculate ball's screen position
            const parallaxFactor = track.config.main ? 1 : 0.95 - (track.config.distance * 0.05);
            const ballX = ball.position * canvas.width;
            const adjustedX = ballX - cameraOffset * (1 - parallaxFactor);
            
            // Get Y position
            const dataIndex = Math.floor(ball.position * (track.data.length - 1));
            const ballY = canvas.height - (track.data[dataIndex].scores.test / 100 * canvas.height) - 15;
            
            // Convert to container coordinates
            const containerX = adjustedX - cameraOffset;
            const containerY = ballY;
            
            showClickFeedback(containerX, containerY, type);
        }
        
        // Visual feedback for clicks with animated circles
        function showClickFeedback(x, y, type) {
            // Create circle effect
            const circle = document.createElement('div');
            circle.style.cssText = `
                position: absolute;
                left: ${x}px;
                top: ${y}px;
                pointer-events: none;
                border-radius: 50%;
                border: 3px solid;
                transform: translate(-50%, -50%);
                animation: pushCircle 0.6s ease-out;
                z-index: 1000;
            `;
            
            // Create arrow/symbol
            const feedback = document.createElement('div');
            feedback.style.cssText = `
                position: absolute;
                left: ${x}px;
                top: ${y}px;
                pointer-events: none;
                font-weight: bold;
                font-size: 24px;
                transform: translate(-50%, -50%);
                animation: fadeOut 0.5s ease-out;
                z-index: 1001;
            `;
            
            if (type === 'push-right') {
                feedback.textContent = '→';
                feedback.style.color = '#4CAF50';
                circle.style.borderColor = '#4CAF50';
            } else if (type === 'push-left') {
                feedback.textContent = '←';
                feedback.style.color = '#2196F3';
                circle.style.borderColor = '#2196F3';
            } else {
                feedback.textContent = '✗';
                feedback.style.color = '#f44336';
                circle.style.borderColor = '#f44336';
            }
            
            canvasContainer.appendChild(circle);
            canvasContainer.appendChild(feedback);
            setTimeout(() => {
                circle.remove();
                feedback.remove();
            }, 600);
        }
        
        // Add CSS animations for feedback
        const style = document.createElement('style');
        style.textContent = `
            @keyframes fadeOut {
                0% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
            }
            @keyframes pushCircle {
                0% { 
                    width: 30px; 
                    height: 30px; 
                    opacity: 1;
                }
                100% { 
                    width: 80px; 
                    height: 80px; 
                    opacity: 0;
                }
            }
        `;
        document.head.appendChild(style);
        
        // Function to update race statistics
        function updateRaceStats() {
            const statsDiv = document.getElementById('race-stats');
            const statsContent = document.getElementById('stats-content');
            
            if (raceStarted && raceStartTime) {
                statsDiv.style.display = 'block';
                const currentTime = (Date.now() - raceStartTime) / 1000;
                
                let statsHTML = `<div>Race Time: ${currentTime.toFixed(1)}s</div>`;
                
                // Sort balls by position for pole position display
                const ballPositions = trackBalls.map((ball, index) => ({
                    index: index,
                    position: Math.max(0, Math.min(1, ball.position)), // Clamp between 0-1
                    name: ballNames[index],
                    color: ballColors[index],
                    ball: ball
                })).sort((a, b) => b.position - a.position);
                
                // Pole position bars
                statsHTML += `<div style="margin-top: 15px;"><strong>Pole Positions:</strong></div>`;
                statsHTML += `<div style="margin: 10px 0;">`;
                
                ballPositions.forEach((data, rank) => {
                    const barWidth = 150;
                    const filledWidth = data.position * barWidth;
                    
                    statsHTML += `<div style="margin: 3px 0;">`;
                    statsHTML += `<span style="display: inline-block; width: 15px; text-align: right; margin-right: 5px;">${rank + 1}.</span>`;
                    statsHTML += `<span style="display: inline-block; width: 60px;">${data.name}</span>`;
                    
                    // Progress bar
                    statsHTML += `<span style="display: inline-block; width: ${barWidth}px; height: 12px; background: #ddd; position: relative; margin: 0 5px;">`;
                    statsHTML += `<span style="display: block; width: ${filledWidth}px; height: 100%; background: ${data.color};"></span>`;
                    statsHTML += `</span>`;
                    statsHTML += `<span style="font-size: 11px;">${(data.position * 100).toFixed(1)}%</span>`;
                    
                    if (finishResults.find(r => r.ballIndex === data.index)) {
                        statsHTML += ` ✓`;
                    }
                    statsHTML += `</div>`;
                });
                
                statsHTML += `</div>`;
                
                // Detailed stats
                statsHTML += `<div style="margin-top: 15px;"><strong>Click Stats:</strong></div>`;
                statsHTML += `<div style="margin-top: 5px; font-size: 12px;">`;
                
                trackBalls.forEach((ball, index) => {
                    const clicks = index === 0 ? userClickCount : ball.clickCount;
                    const rightPushes = index === 0 ? userPushRightClicks : ball.pushRightClicks;
                    const leftPushes = index === 0 ? userPushLeftClicks : ball.pushLeftClicks;
                    const misses = index === 0 ? userMissClicks : ball.missClicks;
                    
                    statsHTML += `<div style="margin: 3px 0;">`;
                    statsHTML += `<span style="display: inline-block; width: 10px; height: 10px; background: ${ballColors[index]}; 
                                   border-radius: 50%; margin-right: 5px;"></span>`;
                    statsHTML += `${ballNames[index]}: ${clicks} clicks (→${rightPushes} ←${leftPushes} ✗${misses})`;
                    statsHTML += `</div>`;
                });
                
                statsHTML += `</div>`;
                statsContent.innerHTML = statsHTML;
            }
        }
        
        // Function to update race results display
        function updateRaceResults() {
            const resultsDiv = document.getElementById('race-results');
            const tbody = document.getElementById('results-body');
            
            resultsDiv.style.display = 'block';
            tbody.innerHTML = '';
            
            // Sort by finish time
            finishResults.sort((a, b) => a.time - b.time);
            
            finishResults.forEach((result, index) => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td style="padding: 8px; border: 1px solid #ddd;">${index + 1}</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">
                        <span style="display: inline-block; width: 15px; height: 15px; background: ${result.color}; 
                               border-radius: 50%; margin-right: 5px; vertical-align: middle;"></span>
                        ${result.name}
                    </td>
                    <td style="padding: 8px; border: 1px solid #ddd;">${result.time.toFixed(2)}s</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">${result.clicks}</td>
                    <td style="padding: 8px; border: 1px solid #ddd;">${(result.accuracy * 100).toFixed(1)}%</td>
                `;
                tbody.appendChild(row);
            });
            
            // Show race stats
            updateRaceStats();
            
            // Check if all balls finished
            if (finishResults.length === 4) {
                setTimeout(() => {
                    const winner = finishResults[0];
                    console.log(`Race Complete! Winner: ${winner.name} in ${winner.time.toFixed(2)} seconds!`);
                }, 500);
            }
        }
        
        // Initial draw - show empty scene
        ballPosition = 0.01;  // Start slightly from left
        cameraOffset = 0;
        cameraTargetOffset = 0;
        drawEmptyScene();  // Use empty scene instead of full scene
        
        // Auto-start the game after a short delay
        setTimeout(() => {
            startTest();
        }, 1000);
    </script>
</body>
</html>